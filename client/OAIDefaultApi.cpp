/**
 * Discord HTTP API (Preview) - REST API Client
 * Preview of the Discord v10 HTTP API specification. See https://discord.com/developers/docs for more details.
 * 
 * ## Metadata
 *   
 * - **Copyright**: Copyright (c) 2025 Qntx
 * - **Author**: ΣX <gitctrlx@gmail.com>
 * - **Version**: 10
 * - **Modified**: 2025-07-01T06:33:49.033017897Z[Etc/UTC]
 * - **Generator Version**: 7.14.0
 *
 * <details>
 * <summary><strong>⚠️ Important Disclaimer & Limitation of Liability</strong></summary>
 * <br>
 * > **IMPORTANT**: This software is provided "as is" without any warranties, express or implied, including but not limited
 * > to warranties of merchantability, fitness for a particular purpose, or non-infringement. The developers, contributors,
 * > and licensors (collectively, "Developers") make no representations regarding the accuracy, completeness, or reliability
 * > of this software or its outputs.
 * >
 * > This client is not intended to provide financial, investment, tax, or legal advice. It facilitates interaction with the
 * > Discord HTTP API (Preview) service but does not endorse or recommend any financial actions, including the purchase, sale, or holding of
 * > financial instruments (e.g., stocks, bonds, derivatives, cryptocurrencies). Users must consult qualified financial or
 * > legal professionals before making decisions based on this software's outputs.
 * >
 * > Financial markets are inherently speculative and carry significant risks. Using this software in trading, analysis, or
 * > other financial activities may result in substantial losses, including total loss of capital. The Developers are not
 * > liable for any losses or damages arising from such use. Users assume full responsibility for validating the software's
 * > outputs and ensuring their suitability for intended purposes.
 * >
 * > This client may rely on third-party data or services (e.g., market feeds, APIs). The Developers do not control or verify
 * > the accuracy of these services and are not liable for any errors, delays, or losses resulting from their use. Users must
 * > comply with third-party terms and conditions.
 * >
 * > Users are solely responsible for ensuring compliance with all applicable financial, tax, and regulatory requirements in
 * > their jurisdiction. This includes obtaining necessary licenses or approvals for trading or investment activities. The
 * > Developers disclaim liability for any legal consequences arising from non-compliance.
 * >
 * > To the fullest extent permitted by law, the Developers shall not be liable for any direct, indirect, incidental,
 * > consequential, or punitive damages arising from the use or inability to use this software, including but not limited to
 * > loss of profits, data, or business opportunities.
 *
 * </details>
 */

#include "OAIDefaultApi.h"
#include "OAIServerConfiguration.h"
#include <QJsonArray>
#include <QJsonDocument>

namespace dc_rest {

OAIDefaultApi::OAIDefaultApi(const int timeOut)
    : _timeOut(timeOut),
      _manager(nullptr),
      _isResponseCompressionEnabled(false),
      _isRequestCompressionEnabled(false) {
    initializeServerConfigs();
}

OAIDefaultApi::~OAIDefaultApi() {
}

void OAIDefaultApi::initializeServerConfigs() {
    //Default server
    QList<OAIServerConfiguration> defaultConf = QList<OAIServerConfiguration>();
    //varying endpoint server
    defaultConf.append(OAIServerConfiguration(
    QUrl("https://discord.com/api/v10"),
    "No description provided",
    QMap<QString, OAIServerVariable>()));
    _serverConfigs.insert("addGroupDmUser", defaultConf);
    _serverIndices.insert("addGroupDmUser", 0);
    _serverConfigs.insert("addGuildMember", defaultConf);
    _serverIndices.insert("addGuildMember", 0);
    _serverConfigs.insert("addGuildMemberRole", defaultConf);
    _serverIndices.insert("addGuildMemberRole", 0);
    _serverConfigs.insert("addLobbyMember", defaultConf);
    _serverIndices.insert("addLobbyMember", 0);
    _serverConfigs.insert("addMyMessageReaction", defaultConf);
    _serverIndices.insert("addMyMessageReaction", 0);
    _serverConfigs.insert("addThreadMember", defaultConf);
    _serverIndices.insert("addThreadMember", 0);
    _serverConfigs.insert("applicationsGetActivityInstance", defaultConf);
    _serverIndices.insert("applicationsGetActivityInstance", 0);
    _serverConfigs.insert("banUserFromGuild", defaultConf);
    _serverIndices.insert("banUserFromGuild", 0);
    _serverConfigs.insert("bulkBanUsersFromGuild", defaultConf);
    _serverIndices.insert("bulkBanUsersFromGuild", 0);
    _serverConfigs.insert("bulkDeleteMessages", defaultConf);
    _serverIndices.insert("bulkDeleteMessages", 0);
    _serverConfigs.insert("bulkSetApplicationCommands", defaultConf);
    _serverIndices.insert("bulkSetApplicationCommands", 0);
    _serverConfigs.insert("bulkSetGuildApplicationCommands", defaultConf);
    _serverIndices.insert("bulkSetGuildApplicationCommands", 0);
    _serverConfigs.insert("bulkUpdateGuildChannels", defaultConf);
    _serverIndices.insert("bulkUpdateGuildChannels", 0);
    _serverConfigs.insert("bulkUpdateGuildRoles", defaultConf);
    _serverIndices.insert("bulkUpdateGuildRoles", 0);
    _serverConfigs.insert("bulkUpdateLobbyMembers", defaultConf);
    _serverIndices.insert("bulkUpdateLobbyMembers", 0);
    _serverConfigs.insert("consumeEntitlement", defaultConf);
    _serverIndices.insert("consumeEntitlement", 0);
    _serverConfigs.insert("createApplicationCommand", defaultConf);
    _serverIndices.insert("createApplicationCommand", 0);
    _serverConfigs.insert("createApplicationEmoji", defaultConf);
    _serverIndices.insert("createApplicationEmoji", 0);
    _serverConfigs.insert("createAutoModerationRule", defaultConf);
    _serverIndices.insert("createAutoModerationRule", 0);
    _serverConfigs.insert("createChannelInvite", defaultConf);
    _serverIndices.insert("createChannelInvite", 0);
    _serverConfigs.insert("createDm", defaultConf);
    _serverIndices.insert("createDm", 0);
    _serverConfigs.insert("createEntitlement", defaultConf);
    _serverIndices.insert("createEntitlement", 0);
    _serverConfigs.insert("createGuild", defaultConf);
    _serverIndices.insert("createGuild", 0);
    _serverConfigs.insert("createGuildApplicationCommand", defaultConf);
    _serverIndices.insert("createGuildApplicationCommand", 0);
    _serverConfigs.insert("createGuildChannel", defaultConf);
    _serverIndices.insert("createGuildChannel", 0);
    _serverConfigs.insert("createGuildEmoji", defaultConf);
    _serverIndices.insert("createGuildEmoji", 0);
    _serverConfigs.insert("createGuildFromTemplate", defaultConf);
    _serverIndices.insert("createGuildFromTemplate", 0);
    _serverConfigs.insert("createGuildRole", defaultConf);
    _serverIndices.insert("createGuildRole", 0);
    _serverConfigs.insert("createGuildScheduledEvent", defaultConf);
    _serverIndices.insert("createGuildScheduledEvent", 0);
    _serverConfigs.insert("createGuildSoundboardSound", defaultConf);
    _serverIndices.insert("createGuildSoundboardSound", 0);
    _serverConfigs.insert("createGuildSticker", defaultConf);
    _serverIndices.insert("createGuildSticker", 0);
    _serverConfigs.insert("createGuildTemplate", defaultConf);
    _serverIndices.insert("createGuildTemplate", 0);
    _serverConfigs.insert("createInteractionResponse", defaultConf);
    _serverIndices.insert("createInteractionResponse", 0);
    _serverConfigs.insert("createLobby", defaultConf);
    _serverIndices.insert("createLobby", 0);
    _serverConfigs.insert("createLobbyMessage", defaultConf);
    _serverIndices.insert("createLobbyMessage", 0);
    _serverConfigs.insert("createMessage", defaultConf);
    _serverIndices.insert("createMessage", 0);
    _serverConfigs.insert("createOrJoinLobby", defaultConf);
    _serverIndices.insert("createOrJoinLobby", 0);
    _serverConfigs.insert("createPin", defaultConf);
    _serverIndices.insert("createPin", 0);
    _serverConfigs.insert("createStageInstance", defaultConf);
    _serverIndices.insert("createStageInstance", 0);
    _serverConfigs.insert("createThread", defaultConf);
    _serverIndices.insert("createThread", 0);
    _serverConfigs.insert("createThreadFromMessage", defaultConf);
    _serverIndices.insert("createThreadFromMessage", 0);
    _serverConfigs.insert("createWebhook", defaultConf);
    _serverIndices.insert("createWebhook", 0);
    _serverConfigs.insert("crosspostMessage", defaultConf);
    _serverIndices.insert("crosspostMessage", 0);
    _serverConfigs.insert("deleteAllMessageReactions", defaultConf);
    _serverIndices.insert("deleteAllMessageReactions", 0);
    _serverConfigs.insert("deleteAllMessageReactionsByEmoji", defaultConf);
    _serverIndices.insert("deleteAllMessageReactionsByEmoji", 0);
    _serverConfigs.insert("deleteApplicationCommand", defaultConf);
    _serverIndices.insert("deleteApplicationCommand", 0);
    _serverConfigs.insert("deleteApplicationEmoji", defaultConf);
    _serverIndices.insert("deleteApplicationEmoji", 0);
    _serverConfigs.insert("deleteApplicationUserRoleConnection", defaultConf);
    _serverIndices.insert("deleteApplicationUserRoleConnection", 0);
    _serverConfigs.insert("deleteAutoModerationRule", defaultConf);
    _serverIndices.insert("deleteAutoModerationRule", 0);
    _serverConfigs.insert("deleteChannel", defaultConf);
    _serverIndices.insert("deleteChannel", 0);
    _serverConfigs.insert("deleteChannelPermissionOverwrite", defaultConf);
    _serverIndices.insert("deleteChannelPermissionOverwrite", 0);
    _serverConfigs.insert("deleteEntitlement", defaultConf);
    _serverIndices.insert("deleteEntitlement", 0);
    _serverConfigs.insert("deleteGroupDmUser", defaultConf);
    _serverIndices.insert("deleteGroupDmUser", 0);
    _serverConfigs.insert("deleteGuild", defaultConf);
    _serverIndices.insert("deleteGuild", 0);
    _serverConfigs.insert("deleteGuildApplicationCommand", defaultConf);
    _serverIndices.insert("deleteGuildApplicationCommand", 0);
    _serverConfigs.insert("deleteGuildEmoji", defaultConf);
    _serverIndices.insert("deleteGuildEmoji", 0);
    _serverConfigs.insert("deleteGuildIntegration", defaultConf);
    _serverIndices.insert("deleteGuildIntegration", 0);
    _serverConfigs.insert("deleteGuildMember", defaultConf);
    _serverIndices.insert("deleteGuildMember", 0);
    _serverConfigs.insert("deleteGuildMemberRole", defaultConf);
    _serverIndices.insert("deleteGuildMemberRole", 0);
    _serverConfigs.insert("deleteGuildRole", defaultConf);
    _serverIndices.insert("deleteGuildRole", 0);
    _serverConfigs.insert("deleteGuildScheduledEvent", defaultConf);
    _serverIndices.insert("deleteGuildScheduledEvent", 0);
    _serverConfigs.insert("deleteGuildSoundboardSound", defaultConf);
    _serverIndices.insert("deleteGuildSoundboardSound", 0);
    _serverConfigs.insert("deleteGuildSticker", defaultConf);
    _serverIndices.insert("deleteGuildSticker", 0);
    _serverConfigs.insert("deleteGuildTemplate", defaultConf);
    _serverIndices.insert("deleteGuildTemplate", 0);
    _serverConfigs.insert("deleteLobbyMember", defaultConf);
    _serverIndices.insert("deleteLobbyMember", 0);
    _serverConfigs.insert("deleteMessage", defaultConf);
    _serverIndices.insert("deleteMessage", 0);
    _serverConfigs.insert("deleteMyMessageReaction", defaultConf);
    _serverIndices.insert("deleteMyMessageReaction", 0);
    _serverConfigs.insert("deleteOriginalWebhookMessage", defaultConf);
    _serverIndices.insert("deleteOriginalWebhookMessage", 0);
    _serverConfigs.insert("deletePin", defaultConf);
    _serverIndices.insert("deletePin", 0);
    _serverConfigs.insert("deleteStageInstance", defaultConf);
    _serverIndices.insert("deleteStageInstance", 0);
    _serverConfigs.insert("deleteThreadMember", defaultConf);
    _serverIndices.insert("deleteThreadMember", 0);
    _serverConfigs.insert("deleteUserMessageReaction", defaultConf);
    _serverIndices.insert("deleteUserMessageReaction", 0);
    _serverConfigs.insert("deleteWebhook", defaultConf);
    _serverIndices.insert("deleteWebhook", 0);
    _serverConfigs.insert("deleteWebhookByToken", defaultConf);
    _serverIndices.insert("deleteWebhookByToken", 0);
    _serverConfigs.insert("deleteWebhookMessage", defaultConf);
    _serverIndices.insert("deleteWebhookMessage", 0);
    _serverConfigs.insert("deprecatedCreatePin", defaultConf);
    _serverIndices.insert("deprecatedCreatePin", 0);
    _serverConfigs.insert("deprecatedDeletePin", defaultConf);
    _serverIndices.insert("deprecatedDeletePin", 0);
    _serverConfigs.insert("deprecatedListPins", defaultConf);
    _serverIndices.insert("deprecatedListPins", 0);
    _serverConfigs.insert("editLobby", defaultConf);
    _serverIndices.insert("editLobby", 0);
    _serverConfigs.insert("editLobbyChannelLink", defaultConf);
    _serverIndices.insert("editLobbyChannelLink", 0);
    _serverConfigs.insert("executeGithubCompatibleWebhook", defaultConf);
    _serverIndices.insert("executeGithubCompatibleWebhook", 0);
    _serverConfigs.insert("executeSlackCompatibleWebhook", defaultConf);
    _serverIndices.insert("executeSlackCompatibleWebhook", 0);
    _serverConfigs.insert("executeWebhook", defaultConf);
    _serverIndices.insert("executeWebhook", 0);
    _serverConfigs.insert("followChannel", defaultConf);
    _serverIndices.insert("followChannel", 0);
    _serverConfigs.insert("getActiveGuildThreads", defaultConf);
    _serverIndices.insert("getActiveGuildThreads", 0);
    _serverConfigs.insert("getAnswerVoters", defaultConf);
    _serverIndices.insert("getAnswerVoters", 0);
    _serverConfigs.insert("getApplication", defaultConf);
    _serverIndices.insert("getApplication", 0);
    _serverConfigs.insert("getApplicationCommand", defaultConf);
    _serverIndices.insert("getApplicationCommand", 0);
    _serverConfigs.insert("getApplicationEmoji", defaultConf);
    _serverIndices.insert("getApplicationEmoji", 0);
    _serverConfigs.insert("getApplicationRoleConnectionsMetadata", defaultConf);
    _serverIndices.insert("getApplicationRoleConnectionsMetadata", 0);
    _serverConfigs.insert("getApplicationUserRoleConnection", defaultConf);
    _serverIndices.insert("getApplicationUserRoleConnection", 0);
    _serverConfigs.insert("getAutoModerationRule", defaultConf);
    _serverIndices.insert("getAutoModerationRule", 0);
    _serverConfigs.insert("getBotGateway", defaultConf);
    _serverIndices.insert("getBotGateway", 0);
    _serverConfigs.insert("getChannel", defaultConf);
    _serverIndices.insert("getChannel", 0);
    _serverConfigs.insert("getEntitlement", defaultConf);
    _serverIndices.insert("getEntitlement", 0);
    _serverConfigs.insert("getEntitlements", defaultConf);
    _serverIndices.insert("getEntitlements", 0);
    _serverConfigs.insert("getGateway", defaultConf);
    _serverIndices.insert("getGateway", 0);
    _serverConfigs.insert("getGuild", defaultConf);
    _serverIndices.insert("getGuild", 0);
    _serverConfigs.insert("getGuildApplicationCommand", defaultConf);
    _serverIndices.insert("getGuildApplicationCommand", 0);
    _serverConfigs.insert("getGuildApplicationCommandPermissions", defaultConf);
    _serverIndices.insert("getGuildApplicationCommandPermissions", 0);
    _serverConfigs.insert("getGuildBan", defaultConf);
    _serverIndices.insert("getGuildBan", 0);
    _serverConfigs.insert("getGuildEmoji", defaultConf);
    _serverIndices.insert("getGuildEmoji", 0);
    _serverConfigs.insert("getGuildMember", defaultConf);
    _serverIndices.insert("getGuildMember", 0);
    _serverConfigs.insert("getGuildNewMemberWelcome", defaultConf);
    _serverIndices.insert("getGuildNewMemberWelcome", 0);
    _serverConfigs.insert("getGuildPreview", defaultConf);
    _serverIndices.insert("getGuildPreview", 0);
    _serverConfigs.insert("getGuildRole", defaultConf);
    _serverIndices.insert("getGuildRole", 0);
    _serverConfigs.insert("getGuildScheduledEvent", defaultConf);
    _serverIndices.insert("getGuildScheduledEvent", 0);
    _serverConfigs.insert("getGuildSoundboardSound", defaultConf);
    _serverIndices.insert("getGuildSoundboardSound", 0);
    _serverConfigs.insert("getGuildSticker", defaultConf);
    _serverIndices.insert("getGuildSticker", 0);
    _serverConfigs.insert("getGuildTemplate", defaultConf);
    _serverIndices.insert("getGuildTemplate", 0);
    _serverConfigs.insert("getGuildVanityUrl", defaultConf);
    _serverIndices.insert("getGuildVanityUrl", 0);
    _serverConfigs.insert("getGuildWebhooks", defaultConf);
    _serverIndices.insert("getGuildWebhooks", 0);
    _serverConfigs.insert("getGuildWelcomeScreen", defaultConf);
    _serverIndices.insert("getGuildWelcomeScreen", 0);
    _serverConfigs.insert("getGuildWidget", defaultConf);
    _serverIndices.insert("getGuildWidget", 0);
    _serverConfigs.insert("getGuildWidgetPng", defaultConf);
    _serverIndices.insert("getGuildWidgetPng", 0);
    _serverConfigs.insert("getGuildWidgetSettings", defaultConf);
    _serverIndices.insert("getGuildWidgetSettings", 0);
    _serverConfigs.insert("getGuildsOnboarding", defaultConf);
    _serverIndices.insert("getGuildsOnboarding", 0);
    _serverConfigs.insert("getLobby", defaultConf);
    _serverIndices.insert("getLobby", 0);
    _serverConfigs.insert("getLobbyMessages", defaultConf);
    _serverIndices.insert("getLobbyMessages", 0);
    _serverConfigs.insert("getMessage", defaultConf);
    _serverIndices.insert("getMessage", 0);
    _serverConfigs.insert("getMyApplication", defaultConf);
    _serverIndices.insert("getMyApplication", 0);
    _serverConfigs.insert("getMyGuildMember", defaultConf);
    _serverIndices.insert("getMyGuildMember", 0);
    _serverConfigs.insert("getMyOauth2Application", defaultConf);
    _serverIndices.insert("getMyOauth2Application", 0);
    _serverConfigs.insert("getMyOauth2Authorization", defaultConf);
    _serverIndices.insert("getMyOauth2Authorization", 0);
    _serverConfigs.insert("getMyUser", defaultConf);
    _serverIndices.insert("getMyUser", 0);
    _serverConfigs.insert("getOpenidConnectUserinfo", defaultConf);
    _serverIndices.insert("getOpenidConnectUserinfo", 0);
    _serverConfigs.insert("getOriginalWebhookMessage", defaultConf);
    _serverIndices.insert("getOriginalWebhookMessage", 0);
    _serverConfigs.insert("getPublicKeys", defaultConf);
    _serverIndices.insert("getPublicKeys", 0);
    _serverConfigs.insert("getSelfVoiceState", defaultConf);
    _serverIndices.insert("getSelfVoiceState", 0);
    _serverConfigs.insert("getSoundboardDefaultSounds", defaultConf);
    _serverIndices.insert("getSoundboardDefaultSounds", 0);
    _serverConfigs.insert("getStageInstance", defaultConf);
    _serverIndices.insert("getStageInstance", 0);
    _serverConfigs.insert("getSticker", defaultConf);
    _serverIndices.insert("getSticker", 0);
    _serverConfigs.insert("getStickerPack", defaultConf);
    _serverIndices.insert("getStickerPack", 0);
    _serverConfigs.insert("getThreadMember", defaultConf);
    _serverIndices.insert("getThreadMember", 0);
    _serverConfigs.insert("getUser", defaultConf);
    _serverIndices.insert("getUser", 0);
    _serverConfigs.insert("getVoiceState", defaultConf);
    _serverIndices.insert("getVoiceState", 0);
    _serverConfigs.insert("getWebhook", defaultConf);
    _serverIndices.insert("getWebhook", 0);
    _serverConfigs.insert("getWebhookByToken", defaultConf);
    _serverIndices.insert("getWebhookByToken", 0);
    _serverConfigs.insert("getWebhookMessage", defaultConf);
    _serverIndices.insert("getWebhookMessage", 0);
    _serverConfigs.insert("inviteResolve", defaultConf);
    _serverIndices.insert("inviteResolve", 0);
    _serverConfigs.insert("inviteRevoke", defaultConf);
    _serverIndices.insert("inviteRevoke", 0);
    _serverConfigs.insert("joinThread", defaultConf);
    _serverIndices.insert("joinThread", 0);
    _serverConfigs.insert("leaveGuild", defaultConf);
    _serverIndices.insert("leaveGuild", 0);
    _serverConfigs.insert("leaveLobby", defaultConf);
    _serverIndices.insert("leaveLobby", 0);
    _serverConfigs.insert("leaveThread", defaultConf);
    _serverIndices.insert("leaveThread", 0);
    _serverConfigs.insert("listApplicationCommands", defaultConf);
    _serverIndices.insert("listApplicationCommands", 0);
    _serverConfigs.insert("listApplicationEmojis", defaultConf);
    _serverIndices.insert("listApplicationEmojis", 0);
    _serverConfigs.insert("listAutoModerationRules", defaultConf);
    _serverIndices.insert("listAutoModerationRules", 0);
    _serverConfigs.insert("listChannelInvites", defaultConf);
    _serverIndices.insert("listChannelInvites", 0);
    _serverConfigs.insert("listChannelWebhooks", defaultConf);
    _serverIndices.insert("listChannelWebhooks", 0);
    _serverConfigs.insert("listGuildApplicationCommandPermissions", defaultConf);
    _serverIndices.insert("listGuildApplicationCommandPermissions", 0);
    _serverConfigs.insert("listGuildApplicationCommands", defaultConf);
    _serverIndices.insert("listGuildApplicationCommands", 0);
    _serverConfigs.insert("listGuildAuditLogEntries", defaultConf);
    _serverIndices.insert("listGuildAuditLogEntries", 0);
    _serverConfigs.insert("listGuildBans", defaultConf);
    _serverIndices.insert("listGuildBans", 0);
    _serverConfigs.insert("listGuildChannels", defaultConf);
    _serverIndices.insert("listGuildChannels", 0);
    _serverConfigs.insert("listGuildEmojis", defaultConf);
    _serverIndices.insert("listGuildEmojis", 0);
    _serverConfigs.insert("listGuildIntegrations", defaultConf);
    _serverIndices.insert("listGuildIntegrations", 0);
    _serverConfigs.insert("listGuildInvites", defaultConf);
    _serverIndices.insert("listGuildInvites", 0);
    _serverConfigs.insert("listGuildMembers", defaultConf);
    _serverIndices.insert("listGuildMembers", 0);
    _serverConfigs.insert("listGuildRoles", defaultConf);
    _serverIndices.insert("listGuildRoles", 0);
    _serverConfigs.insert("listGuildScheduledEventUsers", defaultConf);
    _serverIndices.insert("listGuildScheduledEventUsers", 0);
    _serverConfigs.insert("listGuildScheduledEvents", defaultConf);
    _serverIndices.insert("listGuildScheduledEvents", 0);
    _serverConfigs.insert("listGuildSoundboardSounds", defaultConf);
    _serverIndices.insert("listGuildSoundboardSounds", 0);
    _serverConfigs.insert("listGuildStickers", defaultConf);
    _serverIndices.insert("listGuildStickers", 0);
    _serverConfigs.insert("listGuildTemplates", defaultConf);
    _serverIndices.insert("listGuildTemplates", 0);
    _serverConfigs.insert("listGuildVoiceRegions", defaultConf);
    _serverIndices.insert("listGuildVoiceRegions", 0);
    _serverConfigs.insert("listMessageReactionsByEmoji", defaultConf);
    _serverIndices.insert("listMessageReactionsByEmoji", 0);
    _serverConfigs.insert("listMessages", defaultConf);
    _serverIndices.insert("listMessages", 0);
    _serverConfigs.insert("listMyConnections", defaultConf);
    _serverIndices.insert("listMyConnections", 0);
    _serverConfigs.insert("listMyGuilds", defaultConf);
    _serverIndices.insert("listMyGuilds", 0);
    _serverConfigs.insert("listMyPrivateArchivedThreads", defaultConf);
    _serverIndices.insert("listMyPrivateArchivedThreads", 0);
    _serverConfigs.insert("listPins", defaultConf);
    _serverIndices.insert("listPins", 0);
    _serverConfigs.insert("listPrivateArchivedThreads", defaultConf);
    _serverIndices.insert("listPrivateArchivedThreads", 0);
    _serverConfigs.insert("listPublicArchivedThreads", defaultConf);
    _serverIndices.insert("listPublicArchivedThreads", 0);
    _serverConfigs.insert("listStickerPacks", defaultConf);
    _serverIndices.insert("listStickerPacks", 0);
    _serverConfigs.insert("listThreadMembers", defaultConf);
    _serverIndices.insert("listThreadMembers", 0);
    _serverConfigs.insert("listVoiceRegions", defaultConf);
    _serverIndices.insert("listVoiceRegions", 0);
    _serverConfigs.insert("partnerSdkToken", defaultConf);
    _serverIndices.insert("partnerSdkToken", 0);
    _serverConfigs.insert("partnerSdkUnmergeProvisionalAccount", defaultConf);
    _serverIndices.insert("partnerSdkUnmergeProvisionalAccount", 0);
    _serverConfigs.insert("pollExpire", defaultConf);
    _serverIndices.insert("pollExpire", 0);
    _serverConfigs.insert("previewPruneGuild", defaultConf);
    _serverIndices.insert("previewPruneGuild", 0);
    _serverConfigs.insert("pruneGuild", defaultConf);
    _serverIndices.insert("pruneGuild", 0);
    _serverConfigs.insert("putGuildsOnboarding", defaultConf);
    _serverIndices.insert("putGuildsOnboarding", 0);
    _serverConfigs.insert("searchGuildMembers", defaultConf);
    _serverIndices.insert("searchGuildMembers", 0);
    _serverConfigs.insert("sendSoundboardSound", defaultConf);
    _serverIndices.insert("sendSoundboardSound", 0);
    _serverConfigs.insert("setChannelPermissionOverwrite", defaultConf);
    _serverIndices.insert("setChannelPermissionOverwrite", 0);
    _serverConfigs.insert("setGuildApplicationCommandPermissions", defaultConf);
    _serverIndices.insert("setGuildApplicationCommandPermissions", 0);
    _serverConfigs.insert("setGuildMfaLevel", defaultConf);
    _serverIndices.insert("setGuildMfaLevel", 0);
    _serverConfigs.insert("syncGuildTemplate", defaultConf);
    _serverIndices.insert("syncGuildTemplate", 0);
    _serverConfigs.insert("threadSearch", defaultConf);
    _serverIndices.insert("threadSearch", 0);
    _serverConfigs.insert("triggerTypingIndicator", defaultConf);
    _serverIndices.insert("triggerTypingIndicator", 0);
    _serverConfigs.insert("unbanUserFromGuild", defaultConf);
    _serverIndices.insert("unbanUserFromGuild", 0);
    _serverConfigs.insert("updateApplication", defaultConf);
    _serverIndices.insert("updateApplication", 0);
    _serverConfigs.insert("updateApplicationCommand", defaultConf);
    _serverIndices.insert("updateApplicationCommand", 0);
    _serverConfigs.insert("updateApplicationEmoji", defaultConf);
    _serverIndices.insert("updateApplicationEmoji", 0);
    _serverConfigs.insert("updateApplicationRoleConnectionsMetadata", defaultConf);
    _serverIndices.insert("updateApplicationRoleConnectionsMetadata", 0);
    _serverConfigs.insert("updateApplicationUserRoleConnection", defaultConf);
    _serverIndices.insert("updateApplicationUserRoleConnection", 0);
    _serverConfigs.insert("updateAutoModerationRule", defaultConf);
    _serverIndices.insert("updateAutoModerationRule", 0);
    _serverConfigs.insert("updateChannel", defaultConf);
    _serverIndices.insert("updateChannel", 0);
    _serverConfigs.insert("updateGuild", defaultConf);
    _serverIndices.insert("updateGuild", 0);
    _serverConfigs.insert("updateGuildApplicationCommand", defaultConf);
    _serverIndices.insert("updateGuildApplicationCommand", 0);
    _serverConfigs.insert("updateGuildEmoji", defaultConf);
    _serverIndices.insert("updateGuildEmoji", 0);
    _serverConfigs.insert("updateGuildMember", defaultConf);
    _serverIndices.insert("updateGuildMember", 0);
    _serverConfigs.insert("updateGuildRole", defaultConf);
    _serverIndices.insert("updateGuildRole", 0);
    _serverConfigs.insert("updateGuildScheduledEvent", defaultConf);
    _serverIndices.insert("updateGuildScheduledEvent", 0);
    _serverConfigs.insert("updateGuildSoundboardSound", defaultConf);
    _serverIndices.insert("updateGuildSoundboardSound", 0);
    _serverConfigs.insert("updateGuildSticker", defaultConf);
    _serverIndices.insert("updateGuildSticker", 0);
    _serverConfigs.insert("updateGuildTemplate", defaultConf);
    _serverIndices.insert("updateGuildTemplate", 0);
    _serverConfigs.insert("updateGuildWelcomeScreen", defaultConf);
    _serverIndices.insert("updateGuildWelcomeScreen", 0);
    _serverConfigs.insert("updateGuildWidgetSettings", defaultConf);
    _serverIndices.insert("updateGuildWidgetSettings", 0);
    _serverConfigs.insert("updateMessage", defaultConf);
    _serverIndices.insert("updateMessage", 0);
    _serverConfigs.insert("updateMyApplication", defaultConf);
    _serverIndices.insert("updateMyApplication", 0);
    _serverConfigs.insert("updateMyGuildMember", defaultConf);
    _serverIndices.insert("updateMyGuildMember", 0);
    _serverConfigs.insert("updateMyUser", defaultConf);
    _serverIndices.insert("updateMyUser", 0);
    _serverConfigs.insert("updateOriginalWebhookMessage", defaultConf);
    _serverIndices.insert("updateOriginalWebhookMessage", 0);
    _serverConfigs.insert("updateSelfVoiceState", defaultConf);
    _serverIndices.insert("updateSelfVoiceState", 0);
    _serverConfigs.insert("updateStageInstance", defaultConf);
    _serverIndices.insert("updateStageInstance", 0);
    _serverConfigs.insert("updateVoiceState", defaultConf);
    _serverIndices.insert("updateVoiceState", 0);
    _serverConfigs.insert("updateWebhook", defaultConf);
    _serverIndices.insert("updateWebhook", 0);
    _serverConfigs.insert("updateWebhookByToken", defaultConf);
    _serverIndices.insert("updateWebhookByToken", 0);
    _serverConfigs.insert("updateWebhookMessage", defaultConf);
    _serverIndices.insert("updateWebhookMessage", 0);
    _serverConfigs.insert("uploadApplicationAttachment", defaultConf);
    _serverIndices.insert("uploadApplicationAttachment", 0);
}

/**
* returns 0 on success and -1, -2 or -3 on failure.
* -1 when the variable does not exist and -2 if the value is not defined in the enum and -3 if the operation or server index is not found
*/
int OAIDefaultApi::setDefaultServerValue(int serverIndex, const QString &operation, const QString &variable, const QString &value) {
    auto it = _serverConfigs.find(operation);
    if (it != _serverConfigs.end() && serverIndex < it.value().size()) {
      return _serverConfigs[operation][serverIndex].setDefaultValue(variable,value);
    }
    return -3;
}
void OAIDefaultApi::setServerIndex(const QString &operation, int serverIndex) {
    if (_serverIndices.contains(operation) && serverIndex < _serverConfigs.find(operation).value().size()) {
        _serverIndices[operation] = serverIndex;
    }
}

void OAIDefaultApi::setApiKey(const QString &apiKeyName, const QString &apiKey) {
    _apiKeys.insert(apiKeyName, apiKey);
}

void OAIDefaultApi::setBearerToken(const QString &token) {
    _bearerToken = token;
}

void OAIDefaultApi::setUsername(const QString &username) {
    _username = username;
}

void OAIDefaultApi::setPassword(const QString &password) {
    _password = password;
}


void OAIDefaultApi::setTimeOut(const int timeOut) {
    _timeOut = timeOut;
}

void OAIDefaultApi::setWorkingDirectory(const QString &path) {
    _workingDirectory = path;
}

void OAIDefaultApi::setNetworkAccessManager(QNetworkAccessManager* manager) {
    _manager = manager;
}

/**
    * Appends a new ServerConfiguration to the config map for a specific operation.
    * @param operation The id to the target operation.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    * returns the index of the new server config on success and -1 if the operation is not found
    */
int OAIDefaultApi::addServerConfiguration(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    if (_serverConfigs.contains(operation)) {
        _serverConfigs[operation].append(OAIServerConfiguration(
                    url,
                    description,
                    variables));
        return _serverConfigs[operation].size()-1;
    } else {
        return -1;
    }
}

/**
    * Appends a new ServerConfiguration to the config map for a all operations and sets the index to that server.
    * @param url A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIDefaultApi::setNewServerForAllOperations(const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    for (auto keyIt = _serverIndices.keyBegin(); keyIt != _serverIndices.keyEnd(); keyIt++) {
        setServerIndex(*keyIt, addServerConfiguration(*keyIt, url, description, variables));
    }
}

/**
    * Appends a new ServerConfiguration to the config map for an operations and sets the index to that server.
    * @param URL A string that contains the URL of the server
    * @param description A String that describes the server
    * @param variables A map between a variable name and its value. The value is used for substitution in the server's URL template.
    */
void OAIDefaultApi::setNewServer(const QString &operation, const QUrl &url, const QString &description, const QMap<QString, OAIServerVariable> &variables) {
    setServerIndex(operation, addServerConfiguration(operation, url, description, variables));
}

void OAIDefaultApi::addHeaders(const QString &key, const QString &value) {
    _defaultHeaders.insert(key, value);
}

void OAIDefaultApi::enableRequestCompression() {
    _isRequestCompressionEnabled = true;
}

void OAIDefaultApi::enableResponseCompression() {
    _isResponseCompressionEnabled = true;
}

void OAIDefaultApi::abortRequests() {
    Q_EMIT abortRequestsSignal();
}

QString OAIDefaultApi::getParamStylePrefix(const QString &style) {
    if (style == "matrix") {
        return ";";
    } else if (style == "label") {
        return ".";
    } else if (style == "form") {
        return "&";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "&";
    } else if (style == "pipeDelimited") {
        return "&";
    } else {
        return "none";
    }
}

QString OAIDefaultApi::getParamStyleSuffix(const QString &style) {
    if (style == "matrix") {
        return "=";
    } else if (style == "label") {
        return "";
    } else if (style == "form") {
        return "=";
    } else if (style == "simple") {
        return "";
    } else if (style == "spaceDelimited") {
        return "=";
    } else if (style == "pipeDelimited") {
        return "=";
    } else {
        return "none";
    }
}

QString OAIDefaultApi::getParamStyleDelimiter(const QString &style, const QString &name, bool isExplode) {

    if (style == "matrix") {
        return (isExplode) ? ";" + name + "=" : ",";

    } else if (style == "label") {
        return (isExplode) ? "." : ",";

    } else if (style == "form") {
        return (isExplode) ? "&" + name + "=" : ",";

    } else if (style == "simple") {
        return ",";
    } else if (style == "spaceDelimited") {
        return (isExplode) ? "&" + name + "=" : " ";

    } else if (style == "pipeDelimited") {
        return (isExplode) ? "&" + name + "=" : "|";

    } else if (style == "deepObject") {
        return (isExplode) ? "&" : "none";

    } else {
        return "none";
    }
}

void OAIDefaultApi::addGroupDmUser(const QString &channel_id, const QString &user_id, const OAIAdd_group_dm_user_request &oai_add_group_dm_user_request) {
    QString fullPath = QString(_serverConfigs["addGroupDmUser"][_serverIndices.value("addGroupDmUser")].URL()+"/channels/{channel_id}/recipients/{user_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    
    {
        QString user_idPathParam("{");
        user_idPathParam.append("user_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "user_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"user_id"+pathSuffix : pathPrefix;
        fullPath.replace(user_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(user_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_add_group_dm_user_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::addGroupDmUserCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::addGroupDmUserCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIAdd_group_dm_user_201_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT addGroupDmUserSignal(output);
        Q_EMIT addGroupDmUserSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT addGroupDmUserSignalE(output, error_type, error_str);
        Q_EMIT addGroupDmUserSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT addGroupDmUserSignalError(output, error_type, error_str);
        Q_EMIT addGroupDmUserSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::addGuildMember(const QString &guild_id, const QString &user_id, const OAIAdd_guild_member_request &oai_add_guild_member_request) {
    QString fullPath = QString(_serverConfigs["addGuildMember"][_serverIndices.value("addGuildMember")].URL()+"/guilds/{guild_id}/members/{user_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString user_idPathParam("{");
        user_idPathParam.append("user_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "user_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"user_id"+pathSuffix : pathPrefix;
        fullPath.replace(user_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(user_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_add_guild_member_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::addGuildMemberCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::addGuildMemberCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildMemberResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT addGuildMemberSignal(output);
        Q_EMIT addGuildMemberSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT addGuildMemberSignalE(output, error_type, error_str);
        Q_EMIT addGuildMemberSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT addGuildMemberSignalError(output, error_type, error_str);
        Q_EMIT addGuildMemberSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::addGuildMemberRole(const QString &guild_id, const QString &user_id, const QString &role_id) {
    QString fullPath = QString(_serverConfigs["addGuildMemberRole"][_serverIndices.value("addGuildMemberRole")].URL()+"/guilds/{guild_id}/members/{user_id}/roles/{role_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString user_idPathParam("{");
        user_idPathParam.append("user_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "user_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"user_id"+pathSuffix : pathPrefix;
        fullPath.replace(user_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(user_id)));
    }
    
    {
        QString role_idPathParam("{");
        role_idPathParam.append("role_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "role_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"role_id"+pathSuffix : pathPrefix;
        fullPath.replace(role_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(role_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::addGuildMemberRoleCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::addGuildMemberRoleCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT addGuildMemberRoleSignal();
        Q_EMIT addGuildMemberRoleSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT addGuildMemberRoleSignalE(error_type, error_str);
        Q_EMIT addGuildMemberRoleSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT addGuildMemberRoleSignalError(error_type, error_str);
        Q_EMIT addGuildMemberRoleSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::addLobbyMember(const QString &lobby_id, const QString &user_id, const OAIAdd_lobby_member_request &oai_add_lobby_member_request) {
    QString fullPath = QString(_serverConfigs["addLobbyMember"][_serverIndices.value("addLobbyMember")].URL()+"/lobbies/{lobby_id}/members/{user_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString lobby_idPathParam("{");
        lobby_idPathParam.append("lobby_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "lobby_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"lobby_id"+pathSuffix : pathPrefix;
        fullPath.replace(lobby_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(lobby_id)));
    }
    
    {
        QString user_idPathParam("{");
        user_idPathParam.append("user_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "user_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"user_id"+pathSuffix : pathPrefix;
        fullPath.replace(user_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(user_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_add_lobby_member_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::addLobbyMemberCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::addLobbyMemberCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAILobbyMemberResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT addLobbyMemberSignal(output);
        Q_EMIT addLobbyMemberSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT addLobbyMemberSignalE(output, error_type, error_str);
        Q_EMIT addLobbyMemberSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT addLobbyMemberSignalError(output, error_type, error_str);
        Q_EMIT addLobbyMemberSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::addMyMessageReaction(const QString &channel_id, const QString &message_id, const QString &emoji_name) {
    QString fullPath = QString(_serverConfigs["addMyMessageReaction"][_serverIndices.value("addMyMessageReaction")].URL()+"/channels/{channel_id}/messages/{message_id}/reactions/{emoji_name}/@me");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    
    {
        QString message_idPathParam("{");
        message_idPathParam.append("message_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "message_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"message_id"+pathSuffix : pathPrefix;
        fullPath.replace(message_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(message_id)));
    }
    
    {
        QString emoji_namePathParam("{");
        emoji_namePathParam.append("emoji_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "emoji_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"emoji_name"+pathSuffix : pathPrefix;
        fullPath.replace(emoji_namePathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(emoji_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::addMyMessageReactionCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::addMyMessageReactionCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT addMyMessageReactionSignal();
        Q_EMIT addMyMessageReactionSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT addMyMessageReactionSignalE(error_type, error_str);
        Q_EMIT addMyMessageReactionSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT addMyMessageReactionSignalError(error_type, error_str);
        Q_EMIT addMyMessageReactionSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::addThreadMember(const QString &channel_id, const QString &user_id) {
    QString fullPath = QString(_serverConfigs["addThreadMember"][_serverIndices.value("addThreadMember")].URL()+"/channels/{channel_id}/thread-members/{user_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    
    {
        QString user_idPathParam("{");
        user_idPathParam.append("user_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "user_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"user_id"+pathSuffix : pathPrefix;
        fullPath.replace(user_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(user_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::addThreadMemberCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::addThreadMemberCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT addThreadMemberSignal();
        Q_EMIT addThreadMemberSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT addThreadMemberSignalE(error_type, error_str);
        Q_EMIT addThreadMemberSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT addThreadMemberSignalError(error_type, error_str);
        Q_EMIT addThreadMemberSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::applicationsGetActivityInstance(const QString &application_id, const QString &instance_id) {
    QString fullPath = QString(_serverConfigs["applicationsGetActivityInstance"][_serverIndices.value("applicationsGetActivityInstance")].URL()+"/applications/{application_id}/activity-instances/{instance_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    
    {
        QString instance_idPathParam("{");
        instance_idPathParam.append("instance_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "instance_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"instance_id"+pathSuffix : pathPrefix;
        fullPath.replace(instance_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(instance_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::applicationsGetActivityInstanceCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::applicationsGetActivityInstanceCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIEmbeddedActivityInstance output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT applicationsGetActivityInstanceSignal(output);
        Q_EMIT applicationsGetActivityInstanceSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT applicationsGetActivityInstanceSignalE(output, error_type, error_str);
        Q_EMIT applicationsGetActivityInstanceSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT applicationsGetActivityInstanceSignalError(output, error_type, error_str);
        Q_EMIT applicationsGetActivityInstanceSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::banUserFromGuild(const QString &guild_id, const QString &user_id, const OAIBan_user_from_guild_request &oai_ban_user_from_guild_request) {
    QString fullPath = QString(_serverConfigs["banUserFromGuild"][_serverIndices.value("banUserFromGuild")].URL()+"/guilds/{guild_id}/bans/{user_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString user_idPathParam("{");
        user_idPathParam.append("user_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "user_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"user_id"+pathSuffix : pathPrefix;
        fullPath.replace(user_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(user_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_ban_user_from_guild_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::banUserFromGuildCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::banUserFromGuildCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT banUserFromGuildSignal();
        Q_EMIT banUserFromGuildSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT banUserFromGuildSignalE(error_type, error_str);
        Q_EMIT banUserFromGuildSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT banUserFromGuildSignalError(error_type, error_str);
        Q_EMIT banUserFromGuildSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::bulkBanUsersFromGuild(const QString &guild_id, const OAIBulk_ban_users_from_guild_request &oai_bulk_ban_users_from_guild_request) {
    QString fullPath = QString(_serverConfigs["bulkBanUsersFromGuild"][_serverIndices.value("bulkBanUsersFromGuild")].URL()+"/guilds/{guild_id}/bulk-ban");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_bulk_ban_users_from_guild_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::bulkBanUsersFromGuildCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::bulkBanUsersFromGuildCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIBulkBanUsersResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT bulkBanUsersFromGuildSignal(output);
        Q_EMIT bulkBanUsersFromGuildSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT bulkBanUsersFromGuildSignalE(output, error_type, error_str);
        Q_EMIT bulkBanUsersFromGuildSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT bulkBanUsersFromGuildSignalError(output, error_type, error_str);
        Q_EMIT bulkBanUsersFromGuildSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::bulkDeleteMessages(const QString &channel_id, const OAIBulk_delete_messages_request &oai_bulk_delete_messages_request) {
    QString fullPath = QString(_serverConfigs["bulkDeleteMessages"][_serverIndices.value("bulkDeleteMessages")].URL()+"/channels/{channel_id}/messages/bulk-delete");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_bulk_delete_messages_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::bulkDeleteMessagesCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::bulkDeleteMessagesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT bulkDeleteMessagesSignal();
        Q_EMIT bulkDeleteMessagesSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT bulkDeleteMessagesSignalE(error_type, error_str);
        Q_EMIT bulkDeleteMessagesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT bulkDeleteMessagesSignalError(error_type, error_str);
        Q_EMIT bulkDeleteMessagesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::bulkSetApplicationCommands(const QString &application_id, const QList<OAIApplicationCommandUpdateRequest> &oai_application_command_update_request) {
    QString fullPath = QString(_serverConfigs["bulkSetApplicationCommands"][_serverIndices.value("bulkSetApplicationCommands")].URL()+"/applications/{application_id}/commands");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {
        QJsonDocument doc(::dc_rest::toJsonValue(oai_application_command_update_request).toArray());
        QByteArray bytes = doc.toJson();
        input.request_body.append(bytes);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::bulkSetApplicationCommandsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::bulkSetApplicationCommandsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("applications.commands.update");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::bulkSetApplicationCommandsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::bulkSetApplicationCommandsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::bulkSetApplicationCommandsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIApplicationCommandResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIApplicationCommandResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT bulkSetApplicationCommandsSignal(output);
        Q_EMIT bulkSetApplicationCommandsSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.commands.update");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT bulkSetApplicationCommandsSignalE(output, error_type, error_str);
        Q_EMIT bulkSetApplicationCommandsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT bulkSetApplicationCommandsSignalError(output, error_type, error_str);
        Q_EMIT bulkSetApplicationCommandsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::bulkSetGuildApplicationCommands(const QString &application_id, const QString &guild_id, const QList<OAIApplicationCommandUpdateRequest> &oai_application_command_update_request) {
    QString fullPath = QString(_serverConfigs["bulkSetGuildApplicationCommands"][_serverIndices.value("bulkSetGuildApplicationCommands")].URL()+"/applications/{application_id}/guilds/{guild_id}/commands");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {
        QJsonDocument doc(::dc_rest::toJsonValue(oai_application_command_update_request).toArray());
        QByteArray bytes = doc.toJson();
        input.request_body.append(bytes);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::bulkSetGuildApplicationCommandsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::bulkSetGuildApplicationCommandsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("applications.commands.update");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::bulkSetGuildApplicationCommandsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::bulkSetGuildApplicationCommandsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::bulkSetGuildApplicationCommandsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIApplicationCommandResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIApplicationCommandResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT bulkSetGuildApplicationCommandsSignal(output);
        Q_EMIT bulkSetGuildApplicationCommandsSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.commands.update");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT bulkSetGuildApplicationCommandsSignalE(output, error_type, error_str);
        Q_EMIT bulkSetGuildApplicationCommandsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT bulkSetGuildApplicationCommandsSignalError(output, error_type, error_str);
        Q_EMIT bulkSetGuildApplicationCommandsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::bulkUpdateGuildChannels(const QString &guild_id, const QList<OAIBulk_update_guild_channels_request_inner> &oai_bulk_update_guild_channels_request_inner) {
    QString fullPath = QString(_serverConfigs["bulkUpdateGuildChannels"][_serverIndices.value("bulkUpdateGuildChannels")].URL()+"/guilds/{guild_id}/channels");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {
        QJsonDocument doc(::dc_rest::toJsonValue(oai_bulk_update_guild_channels_request_inner).toArray());
        QByteArray bytes = doc.toJson();
        input.request_body.append(bytes);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::bulkUpdateGuildChannelsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::bulkUpdateGuildChannelsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT bulkUpdateGuildChannelsSignal();
        Q_EMIT bulkUpdateGuildChannelsSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT bulkUpdateGuildChannelsSignalE(error_type, error_str);
        Q_EMIT bulkUpdateGuildChannelsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT bulkUpdateGuildChannelsSignalError(error_type, error_str);
        Q_EMIT bulkUpdateGuildChannelsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::bulkUpdateGuildRoles(const QString &guild_id, const QList<OAIBulk_update_guild_roles_request_inner> &oai_bulk_update_guild_roles_request_inner) {
    QString fullPath = QString(_serverConfigs["bulkUpdateGuildRoles"][_serverIndices.value("bulkUpdateGuildRoles")].URL()+"/guilds/{guild_id}/roles");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {
        QJsonDocument doc(::dc_rest::toJsonValue(oai_bulk_update_guild_roles_request_inner).toArray());
        QByteArray bytes = doc.toJson();
        input.request_body.append(bytes);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::bulkUpdateGuildRolesCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::bulkUpdateGuildRolesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIGuildRoleResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIGuildRoleResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT bulkUpdateGuildRolesSignal(output);
        Q_EMIT bulkUpdateGuildRolesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT bulkUpdateGuildRolesSignalE(output, error_type, error_str);
        Q_EMIT bulkUpdateGuildRolesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT bulkUpdateGuildRolesSignalError(output, error_type, error_str);
        Q_EMIT bulkUpdateGuildRolesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::bulkUpdateLobbyMembers(const QString &lobby_id, const QList<OAIBulkLobbyMemberRequest> &oai_bulk_lobby_member_request) {
    QString fullPath = QString(_serverConfigs["bulkUpdateLobbyMembers"][_serverIndices.value("bulkUpdateLobbyMembers")].URL()+"/lobbies/{lobby_id}/members/bulk");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString lobby_idPathParam("{");
        lobby_idPathParam.append("lobby_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "lobby_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"lobby_id"+pathSuffix : pathPrefix;
        fullPath.replace(lobby_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(lobby_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {
        QJsonDocument doc(::dc_rest::toJsonValue(oai_bulk_lobby_member_request).toArray());
        QByteArray bytes = doc.toJson();
        input.request_body.append(bytes);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::bulkUpdateLobbyMembersCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::bulkUpdateLobbyMembersCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAILobbyMemberResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAILobbyMemberResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT bulkUpdateLobbyMembersSignal(output);
        Q_EMIT bulkUpdateLobbyMembersSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT bulkUpdateLobbyMembersSignalE(output, error_type, error_str);
        Q_EMIT bulkUpdateLobbyMembersSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT bulkUpdateLobbyMembersSignalError(output, error_type, error_str);
        Q_EMIT bulkUpdateLobbyMembersSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::consumeEntitlement(const QString &application_id, const QString &entitlement_id) {
    QString fullPath = QString(_serverConfigs["consumeEntitlement"][_serverIndices.value("consumeEntitlement")].URL()+"/applications/{application_id}/entitlements/{entitlement_id}/consume");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    
    {
        QString entitlement_idPathParam("{");
        entitlement_idPathParam.append("entitlement_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "entitlement_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"entitlement_id"+pathSuffix : pathPrefix;
        fullPath.replace(entitlement_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(entitlement_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::consumeEntitlementCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    scope.append("applications.entitlements");
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::consumeEntitlementCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("applications.entitlements");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::consumeEntitlementCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("applications.entitlements");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::consumeEntitlementCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::consumeEntitlementCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT consumeEntitlementSignal();
        Q_EMIT consumeEntitlementSignalFull(worker);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.entitlements");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.entitlements");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.entitlements");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT consumeEntitlementSignalE(error_type, error_str);
        Q_EMIT consumeEntitlementSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT consumeEntitlementSignalError(error_type, error_str);
        Q_EMIT consumeEntitlementSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::createApplicationCommand(const QString &application_id, const OAIApplicationCommandCreateRequest &oai_application_command_create_request) {
    QString fullPath = QString(_serverConfigs["createApplicationCommand"][_serverIndices.value("createApplicationCommand")].URL()+"/applications/{application_id}/commands");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_application_command_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("applications.commands.update");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::createApplicationCommandCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIApplicationCommandResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createApplicationCommandSignal(output);
        Q_EMIT createApplicationCommandSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.commands.update");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createApplicationCommandSignalE(output, error_type, error_str);
        Q_EMIT createApplicationCommandSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createApplicationCommandSignalError(output, error_type, error_str);
        Q_EMIT createApplicationCommandSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::createApplicationEmoji(const QString &application_id, const OAICreate_application_emoji_request &oai_create_application_emoji_request) {
    QString fullPath = QString(_serverConfigs["createApplicationEmoji"][_serverIndices.value("createApplicationEmoji")].URL()+"/applications/{application_id}/emojis");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_create_application_emoji_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createApplicationEmojiCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::createApplicationEmojiCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIEmojiResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createApplicationEmojiSignal(output);
        Q_EMIT createApplicationEmojiSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createApplicationEmojiSignalE(output, error_type, error_str);
        Q_EMIT createApplicationEmojiSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createApplicationEmojiSignalError(output, error_type, error_str);
        Q_EMIT createApplicationEmojiSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::createAutoModerationRule(const QString &guild_id, const OAICreate_auto_moderation_rule_request &oai_create_auto_moderation_rule_request) {
    QString fullPath = QString(_serverConfigs["createAutoModerationRule"][_serverIndices.value("createAutoModerationRule")].URL()+"/guilds/{guild_id}/auto-moderation/rules");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_create_auto_moderation_rule_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createAutoModerationRuleCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::createAutoModerationRuleCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreate_auto_moderation_rule_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createAutoModerationRuleSignal(output);
        Q_EMIT createAutoModerationRuleSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createAutoModerationRuleSignalE(output, error_type, error_str);
        Q_EMIT createAutoModerationRuleSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createAutoModerationRuleSignalError(output, error_type, error_str);
        Q_EMIT createAutoModerationRuleSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::createChannelInvite(const QString &channel_id, const OAICreate_channel_invite_request &oai_create_channel_invite_request) {
    QString fullPath = QString(_serverConfigs["createChannelInvite"][_serverIndices.value("createChannelInvite")].URL()+"/channels/{channel_id}/invites");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_create_channel_invite_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createChannelInviteCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::createChannelInviteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIList_channel_invites_200_response_inner output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createChannelInviteSignal(output);
        Q_EMIT createChannelInviteSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createChannelInviteSignalE(output, error_type, error_str);
        Q_EMIT createChannelInviteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createChannelInviteSignalError(output, error_type, error_str);
        Q_EMIT createChannelInviteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::createDm(const OAICreatePrivateChannelRequest &oai_create_private_channel_request) {
    QString fullPath = QString(_serverConfigs["createDm"][_serverIndices.value("createDm")].URL()+"/users/@me/channels");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_create_private_channel_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createDmCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::createDmCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIAdd_group_dm_user_201_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createDmSignal(output);
        Q_EMIT createDmSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createDmSignalE(output, error_type, error_str);
        Q_EMIT createDmSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createDmSignalError(output, error_type, error_str);
        Q_EMIT createDmSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::createEntitlement(const QString &application_id, const OAICreateEntitlementRequestData &oai_create_entitlement_request_data) {
    QString fullPath = QString(_serverConfigs["createEntitlement"][_serverIndices.value("createEntitlement")].URL()+"/applications/{application_id}/entitlements");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_create_entitlement_request_data.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createEntitlementCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::createEntitlementCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIEntitlementResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createEntitlementSignal(output);
        Q_EMIT createEntitlementSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createEntitlementSignalE(output, error_type, error_str);
        Q_EMIT createEntitlementSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createEntitlementSignalError(output, error_type, error_str);
        Q_EMIT createEntitlementSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::createGuild(const OAIGuildCreateRequest &oai_guild_create_request) {
    QString fullPath = QString(_serverConfigs["createGuild"][_serverIndices.value("createGuild")].URL()+"/guilds");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_guild_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createGuildCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::createGuildCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createGuildSignal(output);
        Q_EMIT createGuildSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createGuildSignalE(output, error_type, error_str);
        Q_EMIT createGuildSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createGuildSignalError(output, error_type, error_str);
        Q_EMIT createGuildSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::createGuildApplicationCommand(const QString &application_id, const QString &guild_id, const OAIApplicationCommandCreateRequest &oai_application_command_create_request) {
    QString fullPath = QString(_serverConfigs["createGuildApplicationCommand"][_serverIndices.value("createGuildApplicationCommand")].URL()+"/applications/{application_id}/guilds/{guild_id}/commands");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_application_command_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createGuildApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createGuildApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("applications.commands.update");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createGuildApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createGuildApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::createGuildApplicationCommandCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIApplicationCommandResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createGuildApplicationCommandSignal(output);
        Q_EMIT createGuildApplicationCommandSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.commands.update");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createGuildApplicationCommandSignalE(output, error_type, error_str);
        Q_EMIT createGuildApplicationCommandSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createGuildApplicationCommandSignalError(output, error_type, error_str);
        Q_EMIT createGuildApplicationCommandSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::createGuildChannel(const QString &guild_id, const OAICreateGuildChannelRequest &oai_create_guild_channel_request) {
    QString fullPath = QString(_serverConfigs["createGuildChannel"][_serverIndices.value("createGuildChannel")].URL()+"/guilds/{guild_id}/channels");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_create_guild_channel_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createGuildChannelCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::createGuildChannelCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildChannelResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createGuildChannelSignal(output);
        Q_EMIT createGuildChannelSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createGuildChannelSignalE(output, error_type, error_str);
        Q_EMIT createGuildChannelSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createGuildChannelSignalError(output, error_type, error_str);
        Q_EMIT createGuildChannelSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::createGuildEmoji(const QString &guild_id, const OAICreate_guild_emoji_request &oai_create_guild_emoji_request) {
    QString fullPath = QString(_serverConfigs["createGuildEmoji"][_serverIndices.value("createGuildEmoji")].URL()+"/guilds/{guild_id}/emojis");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_create_guild_emoji_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createGuildEmojiCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::createGuildEmojiCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIEmojiResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createGuildEmojiSignal(output);
        Q_EMIT createGuildEmojiSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createGuildEmojiSignalE(output, error_type, error_str);
        Q_EMIT createGuildEmojiSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createGuildEmojiSignalError(output, error_type, error_str);
        Q_EMIT createGuildEmojiSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::createGuildFromTemplate(const QString &code, const OAICreate_guild_from_template_request &oai_create_guild_from_template_request) {
    QString fullPath = QString(_serverConfigs["createGuildFromTemplate"][_serverIndices.value("createGuildFromTemplate")].URL()+"/guilds/templates/{code}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString codePathParam("{");
        codePathParam.append("code").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "code", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"code"+pathSuffix : pathPrefix;
        fullPath.replace(codePathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(code)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_create_guild_from_template_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createGuildFromTemplateCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::createGuildFromTemplateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createGuildFromTemplateSignal(output);
        Q_EMIT createGuildFromTemplateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createGuildFromTemplateSignalE(output, error_type, error_str);
        Q_EMIT createGuildFromTemplateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createGuildFromTemplateSignalError(output, error_type, error_str);
        Q_EMIT createGuildFromTemplateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::createGuildRole(const QString &guild_id, const OAICreate_guild_role_request &oai_create_guild_role_request) {
    QString fullPath = QString(_serverConfigs["createGuildRole"][_serverIndices.value("createGuildRole")].URL()+"/guilds/{guild_id}/roles");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_create_guild_role_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createGuildRoleCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::createGuildRoleCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildRoleResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createGuildRoleSignal(output);
        Q_EMIT createGuildRoleSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createGuildRoleSignalE(output, error_type, error_str);
        Q_EMIT createGuildRoleSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createGuildRoleSignalError(output, error_type, error_str);
        Q_EMIT createGuildRoleSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::createGuildScheduledEvent(const QString &guild_id, const OAICreate_guild_scheduled_event_request &oai_create_guild_scheduled_event_request) {
    QString fullPath = QString(_serverConfigs["createGuildScheduledEvent"][_serverIndices.value("createGuildScheduledEvent")].URL()+"/guilds/{guild_id}/scheduled-events");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_create_guild_scheduled_event_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createGuildScheduledEventCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::createGuildScheduledEventCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIList_guild_scheduled_events_200_response_inner output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createGuildScheduledEventSignal(output);
        Q_EMIT createGuildScheduledEventSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createGuildScheduledEventSignalE(output, error_type, error_str);
        Q_EMIT createGuildScheduledEventSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createGuildScheduledEventSignalError(output, error_type, error_str);
        Q_EMIT createGuildScheduledEventSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::createGuildSoundboardSound(const QString &guild_id, const OAISoundboardCreateRequest &oai_soundboard_create_request) {
    QString fullPath = QString(_serverConfigs["createGuildSoundboardSound"][_serverIndices.value("createGuildSoundboardSound")].URL()+"/guilds/{guild_id}/soundboard-sounds");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_soundboard_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createGuildSoundboardSoundCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::createGuildSoundboardSoundCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISoundboardSoundResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createGuildSoundboardSoundSignal(output);
        Q_EMIT createGuildSoundboardSoundSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createGuildSoundboardSoundSignalE(output, error_type, error_str);
        Q_EMIT createGuildSoundboardSoundSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createGuildSoundboardSoundSignalError(output, error_type, error_str);
        Q_EMIT createGuildSoundboardSoundSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::createGuildSticker(const QString &guild_id, const QString &name, const QString &tags, const QString &file, const ::dc_rest::OptionalParam<QString> &description) {
    QString fullPath = QString(_serverConfigs["createGuildSticker"][_serverIndices.value("createGuildSticker")].URL()+"/guilds/{guild_id}/stickers");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("name", ::dc_rest::toStringValue(name));
    }
    
    {
        input.add_var("tags", ::dc_rest::toStringValue(tags));
    }
    if (description.hasValue())
    {
        input.add_var("description", ::dc_rest::toStringValue(description.value()));
    }
    
    {
        input.add_var("file", ::dc_rest::toStringValue(file));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createGuildStickerCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::createGuildStickerCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildStickerResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createGuildStickerSignal(output);
        Q_EMIT createGuildStickerSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createGuildStickerSignalE(output, error_type, error_str);
        Q_EMIT createGuildStickerSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createGuildStickerSignalError(output, error_type, error_str);
        Q_EMIT createGuildStickerSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::createGuildTemplate(const QString &guild_id, const OAICreate_guild_template_request &oai_create_guild_template_request) {
    QString fullPath = QString(_serverConfigs["createGuildTemplate"][_serverIndices.value("createGuildTemplate")].URL()+"/guilds/{guild_id}/templates");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_create_guild_template_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createGuildTemplateCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::createGuildTemplateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildTemplateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createGuildTemplateSignal(output);
        Q_EMIT createGuildTemplateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createGuildTemplateSignalE(output, error_type, error_str);
        Q_EMIT createGuildTemplateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createGuildTemplateSignalError(output, error_type, error_str);
        Q_EMIT createGuildTemplateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::createInteractionResponse(const QString &interaction_id, const QString &interaction_token, const OAICreate_interaction_response_request &oai_create_interaction_response_request, const ::dc_rest::OptionalParam<bool> &with_response) {
    QString fullPath = QString(_serverConfigs["createInteractionResponse"][_serverIndices.value("createInteractionResponse")].URL()+"/interactions/{interaction_id}/{interaction_token}/callback");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString interaction_idPathParam("{");
        interaction_idPathParam.append("interaction_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "interaction_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"interaction_id"+pathSuffix : pathPrefix;
        fullPath.replace(interaction_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(interaction_id)));
    }
    
    {
        QString interaction_tokenPathParam("{");
        interaction_tokenPathParam.append("interaction_token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "interaction_token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"interaction_token"+pathSuffix : pathPrefix;
        fullPath.replace(interaction_tokenPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(interaction_token)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (with_response.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "with_response", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("with_response")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(with_response.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_create_interaction_response_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createInteractionResponseCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::createInteractionResponseCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIInteractionCallbackResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createInteractionResponseSignal(output);
        Q_EMIT createInteractionResponseSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createInteractionResponseSignalE(output, error_type, error_str);
        Q_EMIT createInteractionResponseSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createInteractionResponseSignalError(output, error_type, error_str);
        Q_EMIT createInteractionResponseSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::createLobby(const OAICreate_lobby_request &oai_create_lobby_request) {
    QString fullPath = QString(_serverConfigs["createLobby"][_serverIndices.value("createLobby")].URL()+"/lobbies");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_create_lobby_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createLobbyCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::createLobbyCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAILobbyResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createLobbySignal(output);
        Q_EMIT createLobbySignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createLobbySignalE(output, error_type, error_str);
        Q_EMIT createLobbySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createLobbySignalError(output, error_type, error_str);
        Q_EMIT createLobbySignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::createLobbyMessage(const QString &lobby_id, const OAISDKMessageRequest &oaisdk_message_request) {
    QString fullPath = QString(_serverConfigs["createLobbyMessage"][_serverIndices.value("createLobbyMessage")].URL()+"/lobbies/{lobby_id}/messages");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString lobby_idPathParam("{");
        lobby_idPathParam.append("lobby_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "lobby_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"lobby_id"+pathSuffix : pathPrefix;
        fullPath.replace(lobby_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(lobby_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oaisdk_message_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createLobbyMessageCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createLobbyMessageCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createLobbyMessageCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createLobbyMessageCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::createLobbyMessageCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAILobbyMessageResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createLobbyMessageSignal(output);
        Q_EMIT createLobbyMessageSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createLobbyMessageSignalE(output, error_type, error_str);
        Q_EMIT createLobbyMessageSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createLobbyMessageSignalError(output, error_type, error_str);
        Q_EMIT createLobbyMessageSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::createMessage(const QString &channel_id, const OAIMessageCreateRequest &oai_message_create_request) {
    QString fullPath = QString(_serverConfigs["createMessage"][_serverIndices.value("createMessage")].URL()+"/channels/{channel_id}/messages");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_message_create_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createMessageCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::createMessageCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessageResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createMessageSignal(output);
        Q_EMIT createMessageSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createMessageSignalE(output, error_type, error_str);
        Q_EMIT createMessageSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createMessageSignalError(output, error_type, error_str);
        Q_EMIT createMessageSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::createOrJoinLobby(const OAICreate_or_join_lobby_request &oai_create_or_join_lobby_request) {
    QString fullPath = QString(_serverConfigs["createOrJoinLobby"][_serverIndices.value("createOrJoinLobby")].URL()+"/lobbies");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_create_or_join_lobby_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createOrJoinLobbyCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createOrJoinLobbyCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createOrJoinLobbyCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createOrJoinLobbyCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::createOrJoinLobbyCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAILobbyResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createOrJoinLobbySignal(output);
        Q_EMIT createOrJoinLobbySignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createOrJoinLobbySignalE(output, error_type, error_str);
        Q_EMIT createOrJoinLobbySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createOrJoinLobbySignalError(output, error_type, error_str);
        Q_EMIT createOrJoinLobbySignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::createPin(const QString &channel_id, const QString &message_id) {
    QString fullPath = QString(_serverConfigs["createPin"][_serverIndices.value("createPin")].URL()+"/channels/{channel_id}/messages/pins/{message_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    
    {
        QString message_idPathParam("{");
        message_idPathParam.append("message_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "message_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"message_id"+pathSuffix : pathPrefix;
        fullPath.replace(message_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(message_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createPinCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::createPinCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createPinSignal();
        Q_EMIT createPinSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createPinSignalE(error_type, error_str);
        Q_EMIT createPinSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createPinSignalError(error_type, error_str);
        Q_EMIT createPinSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::createStageInstance(const OAICreate_stage_instance_request &oai_create_stage_instance_request) {
    QString fullPath = QString(_serverConfigs["createStageInstance"][_serverIndices.value("createStageInstance")].URL()+"/stage-instances");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_create_stage_instance_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createStageInstanceCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::createStageInstanceCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStageInstanceResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createStageInstanceSignal(output);
        Q_EMIT createStageInstanceSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createStageInstanceSignalE(output, error_type, error_str);
        Q_EMIT createStageInstanceSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createStageInstanceSignalError(output, error_type, error_str);
        Q_EMIT createStageInstanceSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::createThread(const QString &channel_id, const OAICreate_thread_request &oai_create_thread_request) {
    QString fullPath = QString(_serverConfigs["createThread"][_serverIndices.value("createThread")].URL()+"/channels/{channel_id}/threads");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_create_thread_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createThreadCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::createThreadCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreatedThreadResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createThreadSignal(output);
        Q_EMIT createThreadSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createThreadSignalE(output, error_type, error_str);
        Q_EMIT createThreadSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createThreadSignalError(output, error_type, error_str);
        Q_EMIT createThreadSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::createThreadFromMessage(const QString &channel_id, const QString &message_id, const OAICreateTextThreadWithMessageRequest &oai_create_text_thread_with_message_request) {
    QString fullPath = QString(_serverConfigs["createThreadFromMessage"][_serverIndices.value("createThreadFromMessage")].URL()+"/channels/{channel_id}/messages/{message_id}/threads");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    
    {
        QString message_idPathParam("{");
        message_idPathParam.append("message_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "message_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"message_id"+pathSuffix : pathPrefix;
        fullPath.replace(message_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(message_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_create_text_thread_with_message_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createThreadFromMessageCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::createThreadFromMessageCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIThreadResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createThreadFromMessageSignal(output);
        Q_EMIT createThreadFromMessageSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createThreadFromMessageSignalE(output, error_type, error_str);
        Q_EMIT createThreadFromMessageSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createThreadFromMessageSignalError(output, error_type, error_str);
        Q_EMIT createThreadFromMessageSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::createWebhook(const QString &channel_id, const OAICreate_webhook_request &oai_create_webhook_request) {
    QString fullPath = QString(_serverConfigs["createWebhook"][_serverIndices.value("createWebhook")].URL()+"/channels/{channel_id}/webhooks");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_create_webhook_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::createWebhookCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::createWebhookCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildIncomingWebhookResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT createWebhookSignal(output);
        Q_EMIT createWebhookSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT createWebhookSignalE(output, error_type, error_str);
        Q_EMIT createWebhookSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT createWebhookSignalError(output, error_type, error_str);
        Q_EMIT createWebhookSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::crosspostMessage(const QString &channel_id, const QString &message_id) {
    QString fullPath = QString(_serverConfigs["crosspostMessage"][_serverIndices.value("crosspostMessage")].URL()+"/channels/{channel_id}/messages/{message_id}/crosspost");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    
    {
        QString message_idPathParam("{");
        message_idPathParam.append("message_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "message_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"message_id"+pathSuffix : pathPrefix;
        fullPath.replace(message_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(message_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::crosspostMessageCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::crosspostMessageCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessageResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT crosspostMessageSignal(output);
        Q_EMIT crosspostMessageSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT crosspostMessageSignalE(output, error_type, error_str);
        Q_EMIT crosspostMessageSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT crosspostMessageSignalError(output, error_type, error_str);
        Q_EMIT crosspostMessageSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteAllMessageReactions(const QString &channel_id, const QString &message_id) {
    QString fullPath = QString(_serverConfigs["deleteAllMessageReactions"][_serverIndices.value("deleteAllMessageReactions")].URL()+"/channels/{channel_id}/messages/{message_id}/reactions");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    
    {
        QString message_idPathParam("{");
        message_idPathParam.append("message_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "message_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"message_id"+pathSuffix : pathPrefix;
        fullPath.replace(message_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(message_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteAllMessageReactionsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteAllMessageReactionsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteAllMessageReactionsSignal();
        Q_EMIT deleteAllMessageReactionsSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteAllMessageReactionsSignalE(error_type, error_str);
        Q_EMIT deleteAllMessageReactionsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteAllMessageReactionsSignalError(error_type, error_str);
        Q_EMIT deleteAllMessageReactionsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteAllMessageReactionsByEmoji(const QString &channel_id, const QString &message_id, const QString &emoji_name) {
    QString fullPath = QString(_serverConfigs["deleteAllMessageReactionsByEmoji"][_serverIndices.value("deleteAllMessageReactionsByEmoji")].URL()+"/channels/{channel_id}/messages/{message_id}/reactions/{emoji_name}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    
    {
        QString message_idPathParam("{");
        message_idPathParam.append("message_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "message_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"message_id"+pathSuffix : pathPrefix;
        fullPath.replace(message_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(message_id)));
    }
    
    {
        QString emoji_namePathParam("{");
        emoji_namePathParam.append("emoji_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "emoji_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"emoji_name"+pathSuffix : pathPrefix;
        fullPath.replace(emoji_namePathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(emoji_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteAllMessageReactionsByEmojiCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteAllMessageReactionsByEmojiCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteAllMessageReactionsByEmojiSignal();
        Q_EMIT deleteAllMessageReactionsByEmojiSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteAllMessageReactionsByEmojiSignalE(error_type, error_str);
        Q_EMIT deleteAllMessageReactionsByEmojiSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteAllMessageReactionsByEmojiSignalError(error_type, error_str);
        Q_EMIT deleteAllMessageReactionsByEmojiSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteApplicationCommand(const QString &application_id, const QString &command_id) {
    QString fullPath = QString(_serverConfigs["deleteApplicationCommand"][_serverIndices.value("deleteApplicationCommand")].URL()+"/applications/{application_id}/commands/{command_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    
    {
        QString command_idPathParam("{");
        command_idPathParam.append("command_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "command_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"command_id"+pathSuffix : pathPrefix;
        fullPath.replace(command_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(command_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("applications.commands.update");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::deleteApplicationCommandCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteApplicationCommandSignal();
        Q_EMIT deleteApplicationCommandSignalFull(worker);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.commands.update");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteApplicationCommandSignalE(error_type, error_str);
        Q_EMIT deleteApplicationCommandSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteApplicationCommandSignalError(error_type, error_str);
        Q_EMIT deleteApplicationCommandSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteApplicationEmoji(const QString &application_id, const QString &emoji_id) {
    QString fullPath = QString(_serverConfigs["deleteApplicationEmoji"][_serverIndices.value("deleteApplicationEmoji")].URL()+"/applications/{application_id}/emojis/{emoji_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    
    {
        QString emoji_idPathParam("{");
        emoji_idPathParam.append("emoji_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "emoji_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"emoji_id"+pathSuffix : pathPrefix;
        fullPath.replace(emoji_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(emoji_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteApplicationEmojiCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteApplicationEmojiCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteApplicationEmojiSignal();
        Q_EMIT deleteApplicationEmojiSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteApplicationEmojiSignalE(error_type, error_str);
        Q_EMIT deleteApplicationEmojiSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteApplicationEmojiSignalError(error_type, error_str);
        Q_EMIT deleteApplicationEmojiSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteApplicationUserRoleConnection(const QString &application_id) {
    QString fullPath = QString(_serverConfigs["deleteApplicationUserRoleConnection"][_serverIndices.value("deleteApplicationUserRoleConnection")].URL()+"/users/@me/applications/{application_id}/role-connection");
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteApplicationUserRoleConnectionCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteApplicationUserRoleConnectionCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteApplicationUserRoleConnectionCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("role_connections.write");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteApplicationUserRoleConnectionCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::deleteApplicationUserRoleConnectionCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteApplicationUserRoleConnectionSignal();
        Q_EMIT deleteApplicationUserRoleConnectionSignalFull(worker);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("role_connections.write");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteApplicationUserRoleConnectionSignalE(error_type, error_str);
        Q_EMIT deleteApplicationUserRoleConnectionSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteApplicationUserRoleConnectionSignalError(error_type, error_str);
        Q_EMIT deleteApplicationUserRoleConnectionSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteAutoModerationRule(const QString &guild_id, const QString &rule_id) {
    QString fullPath = QString(_serverConfigs["deleteAutoModerationRule"][_serverIndices.value("deleteAutoModerationRule")].URL()+"/guilds/{guild_id}/auto-moderation/rules/{rule_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString rule_idPathParam("{");
        rule_idPathParam.append("rule_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "rule_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"rule_id"+pathSuffix : pathPrefix;
        fullPath.replace(rule_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(rule_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteAutoModerationRuleCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteAutoModerationRuleCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteAutoModerationRuleSignal();
        Q_EMIT deleteAutoModerationRuleSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteAutoModerationRuleSignalE(error_type, error_str);
        Q_EMIT deleteAutoModerationRuleSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteAutoModerationRuleSignalError(error_type, error_str);
        Q_EMIT deleteAutoModerationRuleSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteChannel(const QString &channel_id) {
    QString fullPath = QString(_serverConfigs["deleteChannel"][_serverIndices.value("deleteChannel")].URL()+"/channels/{channel_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteChannelCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteChannelCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGet_channel_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteChannelSignal(output);
        Q_EMIT deleteChannelSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteChannelSignalE(output, error_type, error_str);
        Q_EMIT deleteChannelSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteChannelSignalError(output, error_type, error_str);
        Q_EMIT deleteChannelSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteChannelPermissionOverwrite(const QString &channel_id, const QString &overwrite_id) {
    QString fullPath = QString(_serverConfigs["deleteChannelPermissionOverwrite"][_serverIndices.value("deleteChannelPermissionOverwrite")].URL()+"/channels/{channel_id}/permissions/{overwrite_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    
    {
        QString overwrite_idPathParam("{");
        overwrite_idPathParam.append("overwrite_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "overwrite_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"overwrite_id"+pathSuffix : pathPrefix;
        fullPath.replace(overwrite_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(overwrite_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteChannelPermissionOverwriteCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteChannelPermissionOverwriteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteChannelPermissionOverwriteSignal();
        Q_EMIT deleteChannelPermissionOverwriteSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteChannelPermissionOverwriteSignalE(error_type, error_str);
        Q_EMIT deleteChannelPermissionOverwriteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteChannelPermissionOverwriteSignalError(error_type, error_str);
        Q_EMIT deleteChannelPermissionOverwriteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteEntitlement(const QString &application_id, const QString &entitlement_id) {
    QString fullPath = QString(_serverConfigs["deleteEntitlement"][_serverIndices.value("deleteEntitlement")].URL()+"/applications/{application_id}/entitlements/{entitlement_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    
    {
        QString entitlement_idPathParam("{");
        entitlement_idPathParam.append("entitlement_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "entitlement_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"entitlement_id"+pathSuffix : pathPrefix;
        fullPath.replace(entitlement_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(entitlement_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteEntitlementCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    scope.append("applications.entitlements");
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteEntitlementCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("applications.entitlements");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteEntitlementCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("applications.entitlements");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteEntitlementCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::deleteEntitlementCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteEntitlementSignal();
        Q_EMIT deleteEntitlementSignalFull(worker);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.entitlements");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.entitlements");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.entitlements");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteEntitlementSignalE(error_type, error_str);
        Q_EMIT deleteEntitlementSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteEntitlementSignalError(error_type, error_str);
        Q_EMIT deleteEntitlementSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteGroupDmUser(const QString &channel_id, const QString &user_id) {
    QString fullPath = QString(_serverConfigs["deleteGroupDmUser"][_serverIndices.value("deleteGroupDmUser")].URL()+"/channels/{channel_id}/recipients/{user_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    
    {
        QString user_idPathParam("{");
        user_idPathParam.append("user_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "user_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"user_id"+pathSuffix : pathPrefix;
        fullPath.replace(user_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(user_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteGroupDmUserCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteGroupDmUserCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteGroupDmUserSignal();
        Q_EMIT deleteGroupDmUserSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteGroupDmUserSignalE(error_type, error_str);
        Q_EMIT deleteGroupDmUserSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteGroupDmUserSignalError(error_type, error_str);
        Q_EMIT deleteGroupDmUserSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteGuild(const QString &guild_id) {
    QString fullPath = QString(_serverConfigs["deleteGuild"][_serverIndices.value("deleteGuild")].URL()+"/guilds/{guild_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteGuildCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteGuildCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteGuildSignal();
        Q_EMIT deleteGuildSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteGuildSignalE(error_type, error_str);
        Q_EMIT deleteGuildSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteGuildSignalError(error_type, error_str);
        Q_EMIT deleteGuildSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteGuildApplicationCommand(const QString &application_id, const QString &guild_id, const QString &command_id) {
    QString fullPath = QString(_serverConfigs["deleteGuildApplicationCommand"][_serverIndices.value("deleteGuildApplicationCommand")].URL()+"/applications/{application_id}/guilds/{guild_id}/commands/{command_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString command_idPathParam("{");
        command_idPathParam.append("command_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "command_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"command_id"+pathSuffix : pathPrefix;
        fullPath.replace(command_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(command_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteGuildApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteGuildApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("applications.commands.update");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteGuildApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteGuildApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::deleteGuildApplicationCommandCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteGuildApplicationCommandSignal();
        Q_EMIT deleteGuildApplicationCommandSignalFull(worker);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.commands.update");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteGuildApplicationCommandSignalE(error_type, error_str);
        Q_EMIT deleteGuildApplicationCommandSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteGuildApplicationCommandSignalError(error_type, error_str);
        Q_EMIT deleteGuildApplicationCommandSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteGuildEmoji(const QString &guild_id, const QString &emoji_id) {
    QString fullPath = QString(_serverConfigs["deleteGuildEmoji"][_serverIndices.value("deleteGuildEmoji")].URL()+"/guilds/{guild_id}/emojis/{emoji_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString emoji_idPathParam("{");
        emoji_idPathParam.append("emoji_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "emoji_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"emoji_id"+pathSuffix : pathPrefix;
        fullPath.replace(emoji_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(emoji_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteGuildEmojiCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteGuildEmojiCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteGuildEmojiSignal();
        Q_EMIT deleteGuildEmojiSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteGuildEmojiSignalE(error_type, error_str);
        Q_EMIT deleteGuildEmojiSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteGuildEmojiSignalError(error_type, error_str);
        Q_EMIT deleteGuildEmojiSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteGuildIntegration(const QString &guild_id, const QString &integration_id) {
    QString fullPath = QString(_serverConfigs["deleteGuildIntegration"][_serverIndices.value("deleteGuildIntegration")].URL()+"/guilds/{guild_id}/integrations/{integration_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString integration_idPathParam("{");
        integration_idPathParam.append("integration_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "integration_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"integration_id"+pathSuffix : pathPrefix;
        fullPath.replace(integration_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(integration_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteGuildIntegrationCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteGuildIntegrationCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteGuildIntegrationSignal();
        Q_EMIT deleteGuildIntegrationSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteGuildIntegrationSignalE(error_type, error_str);
        Q_EMIT deleteGuildIntegrationSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteGuildIntegrationSignalError(error_type, error_str);
        Q_EMIT deleteGuildIntegrationSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteGuildMember(const QString &guild_id, const QString &user_id) {
    QString fullPath = QString(_serverConfigs["deleteGuildMember"][_serverIndices.value("deleteGuildMember")].URL()+"/guilds/{guild_id}/members/{user_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString user_idPathParam("{");
        user_idPathParam.append("user_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "user_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"user_id"+pathSuffix : pathPrefix;
        fullPath.replace(user_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(user_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteGuildMemberCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteGuildMemberCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteGuildMemberSignal();
        Q_EMIT deleteGuildMemberSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteGuildMemberSignalE(error_type, error_str);
        Q_EMIT deleteGuildMemberSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteGuildMemberSignalError(error_type, error_str);
        Q_EMIT deleteGuildMemberSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteGuildMemberRole(const QString &guild_id, const QString &user_id, const QString &role_id) {
    QString fullPath = QString(_serverConfigs["deleteGuildMemberRole"][_serverIndices.value("deleteGuildMemberRole")].URL()+"/guilds/{guild_id}/members/{user_id}/roles/{role_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString user_idPathParam("{");
        user_idPathParam.append("user_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "user_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"user_id"+pathSuffix : pathPrefix;
        fullPath.replace(user_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(user_id)));
    }
    
    {
        QString role_idPathParam("{");
        role_idPathParam.append("role_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "role_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"role_id"+pathSuffix : pathPrefix;
        fullPath.replace(role_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(role_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteGuildMemberRoleCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteGuildMemberRoleCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteGuildMemberRoleSignal();
        Q_EMIT deleteGuildMemberRoleSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteGuildMemberRoleSignalE(error_type, error_str);
        Q_EMIT deleteGuildMemberRoleSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteGuildMemberRoleSignalError(error_type, error_str);
        Q_EMIT deleteGuildMemberRoleSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteGuildRole(const QString &guild_id, const QString &role_id) {
    QString fullPath = QString(_serverConfigs["deleteGuildRole"][_serverIndices.value("deleteGuildRole")].URL()+"/guilds/{guild_id}/roles/{role_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString role_idPathParam("{");
        role_idPathParam.append("role_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "role_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"role_id"+pathSuffix : pathPrefix;
        fullPath.replace(role_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(role_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteGuildRoleCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteGuildRoleCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteGuildRoleSignal();
        Q_EMIT deleteGuildRoleSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteGuildRoleSignalE(error_type, error_str);
        Q_EMIT deleteGuildRoleSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteGuildRoleSignalError(error_type, error_str);
        Q_EMIT deleteGuildRoleSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteGuildScheduledEvent(const QString &guild_id, const QString &guild_scheduled_event_id) {
    QString fullPath = QString(_serverConfigs["deleteGuildScheduledEvent"][_serverIndices.value("deleteGuildScheduledEvent")].URL()+"/guilds/{guild_id}/scheduled-events/{guild_scheduled_event_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString guild_scheduled_event_idPathParam("{");
        guild_scheduled_event_idPathParam.append("guild_scheduled_event_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_scheduled_event_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_scheduled_event_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_scheduled_event_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_scheduled_event_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteGuildScheduledEventCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteGuildScheduledEventCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteGuildScheduledEventSignal();
        Q_EMIT deleteGuildScheduledEventSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteGuildScheduledEventSignalE(error_type, error_str);
        Q_EMIT deleteGuildScheduledEventSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteGuildScheduledEventSignalError(error_type, error_str);
        Q_EMIT deleteGuildScheduledEventSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteGuildSoundboardSound(const QString &guild_id, const QString &sound_id) {
    QString fullPath = QString(_serverConfigs["deleteGuildSoundboardSound"][_serverIndices.value("deleteGuildSoundboardSound")].URL()+"/guilds/{guild_id}/soundboard-sounds/{sound_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString sound_idPathParam("{");
        sound_idPathParam.append("sound_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "sound_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"sound_id"+pathSuffix : pathPrefix;
        fullPath.replace(sound_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(sound_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteGuildSoundboardSoundCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteGuildSoundboardSoundCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteGuildSoundboardSoundSignal();
        Q_EMIT deleteGuildSoundboardSoundSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteGuildSoundboardSoundSignalE(error_type, error_str);
        Q_EMIT deleteGuildSoundboardSoundSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteGuildSoundboardSoundSignalError(error_type, error_str);
        Q_EMIT deleteGuildSoundboardSoundSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteGuildSticker(const QString &guild_id, const QString &sticker_id) {
    QString fullPath = QString(_serverConfigs["deleteGuildSticker"][_serverIndices.value("deleteGuildSticker")].URL()+"/guilds/{guild_id}/stickers/{sticker_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString sticker_idPathParam("{");
        sticker_idPathParam.append("sticker_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "sticker_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"sticker_id"+pathSuffix : pathPrefix;
        fullPath.replace(sticker_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(sticker_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteGuildStickerCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteGuildStickerCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteGuildStickerSignal();
        Q_EMIT deleteGuildStickerSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteGuildStickerSignalE(error_type, error_str);
        Q_EMIT deleteGuildStickerSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteGuildStickerSignalError(error_type, error_str);
        Q_EMIT deleteGuildStickerSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteGuildTemplate(const QString &guild_id, const QString &code) {
    QString fullPath = QString(_serverConfigs["deleteGuildTemplate"][_serverIndices.value("deleteGuildTemplate")].URL()+"/guilds/{guild_id}/templates/{code}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString codePathParam("{");
        codePathParam.append("code").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "code", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"code"+pathSuffix : pathPrefix;
        fullPath.replace(codePathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(code)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteGuildTemplateCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteGuildTemplateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildTemplateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteGuildTemplateSignal(output);
        Q_EMIT deleteGuildTemplateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteGuildTemplateSignalE(output, error_type, error_str);
        Q_EMIT deleteGuildTemplateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteGuildTemplateSignalError(output, error_type, error_str);
        Q_EMIT deleteGuildTemplateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteLobbyMember(const QString &lobby_id, const QString &user_id) {
    QString fullPath = QString(_serverConfigs["deleteLobbyMember"][_serverIndices.value("deleteLobbyMember")].URL()+"/lobbies/{lobby_id}/members/{user_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString lobby_idPathParam("{");
        lobby_idPathParam.append("lobby_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "lobby_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"lobby_id"+pathSuffix : pathPrefix;
        fullPath.replace(lobby_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(lobby_id)));
    }
    
    {
        QString user_idPathParam("{");
        user_idPathParam.append("user_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "user_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"user_id"+pathSuffix : pathPrefix;
        fullPath.replace(user_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(user_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteLobbyMemberCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteLobbyMemberCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteLobbyMemberSignal();
        Q_EMIT deleteLobbyMemberSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteLobbyMemberSignalE(error_type, error_str);
        Q_EMIT deleteLobbyMemberSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteLobbyMemberSignalError(error_type, error_str);
        Q_EMIT deleteLobbyMemberSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteMessage(const QString &channel_id, const QString &message_id) {
    QString fullPath = QString(_serverConfigs["deleteMessage"][_serverIndices.value("deleteMessage")].URL()+"/channels/{channel_id}/messages/{message_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    
    {
        QString message_idPathParam("{");
        message_idPathParam.append("message_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "message_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"message_id"+pathSuffix : pathPrefix;
        fullPath.replace(message_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(message_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteMessageCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteMessageCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteMessageSignal();
        Q_EMIT deleteMessageSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteMessageSignalE(error_type, error_str);
        Q_EMIT deleteMessageSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteMessageSignalError(error_type, error_str);
        Q_EMIT deleteMessageSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteMyMessageReaction(const QString &channel_id, const QString &message_id, const QString &emoji_name) {
    QString fullPath = QString(_serverConfigs["deleteMyMessageReaction"][_serverIndices.value("deleteMyMessageReaction")].URL()+"/channels/{channel_id}/messages/{message_id}/reactions/{emoji_name}/@me");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    
    {
        QString message_idPathParam("{");
        message_idPathParam.append("message_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "message_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"message_id"+pathSuffix : pathPrefix;
        fullPath.replace(message_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(message_id)));
    }
    
    {
        QString emoji_namePathParam("{");
        emoji_namePathParam.append("emoji_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "emoji_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"emoji_name"+pathSuffix : pathPrefix;
        fullPath.replace(emoji_namePathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(emoji_name)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteMyMessageReactionCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteMyMessageReactionCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteMyMessageReactionSignal();
        Q_EMIT deleteMyMessageReactionSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteMyMessageReactionSignalE(error_type, error_str);
        Q_EMIT deleteMyMessageReactionSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteMyMessageReactionSignalError(error_type, error_str);
        Q_EMIT deleteMyMessageReactionSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteOriginalWebhookMessage(const QString &webhook_id, const QString &webhook_token, const ::dc_rest::OptionalParam<QString> &thread_id) {
    QString fullPath = QString(_serverConfigs["deleteOriginalWebhookMessage"][_serverIndices.value("deleteOriginalWebhookMessage")].URL()+"/webhooks/{webhook_id}/{webhook_token}/messages/@original");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString webhook_idPathParam("{");
        webhook_idPathParam.append("webhook_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_id"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_id)));
    }
    
    {
        QString webhook_tokenPathParam("{");
        webhook_tokenPathParam.append("webhook_token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_token"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_tokenPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_token)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (thread_id.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "thread_id", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("thread_id")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(thread_id.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteOriginalWebhookMessageCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteOriginalWebhookMessageCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteOriginalWebhookMessageSignal();
        Q_EMIT deleteOriginalWebhookMessageSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteOriginalWebhookMessageSignalE(error_type, error_str);
        Q_EMIT deleteOriginalWebhookMessageSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteOriginalWebhookMessageSignalError(error_type, error_str);
        Q_EMIT deleteOriginalWebhookMessageSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deletePin(const QString &channel_id, const QString &message_id) {
    QString fullPath = QString(_serverConfigs["deletePin"][_serverIndices.value("deletePin")].URL()+"/channels/{channel_id}/messages/pins/{message_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    
    {
        QString message_idPathParam("{");
        message_idPathParam.append("message_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "message_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"message_id"+pathSuffix : pathPrefix;
        fullPath.replace(message_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(message_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deletePinCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deletePinCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deletePinSignal();
        Q_EMIT deletePinSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deletePinSignalE(error_type, error_str);
        Q_EMIT deletePinSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deletePinSignalError(error_type, error_str);
        Q_EMIT deletePinSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteStageInstance(const QString &channel_id) {
    QString fullPath = QString(_serverConfigs["deleteStageInstance"][_serverIndices.value("deleteStageInstance")].URL()+"/stage-instances/{channel_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteStageInstanceCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteStageInstanceCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteStageInstanceSignal();
        Q_EMIT deleteStageInstanceSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteStageInstanceSignalE(error_type, error_str);
        Q_EMIT deleteStageInstanceSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteStageInstanceSignalError(error_type, error_str);
        Q_EMIT deleteStageInstanceSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteThreadMember(const QString &channel_id, const QString &user_id) {
    QString fullPath = QString(_serverConfigs["deleteThreadMember"][_serverIndices.value("deleteThreadMember")].URL()+"/channels/{channel_id}/thread-members/{user_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    
    {
        QString user_idPathParam("{");
        user_idPathParam.append("user_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "user_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"user_id"+pathSuffix : pathPrefix;
        fullPath.replace(user_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(user_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteThreadMemberCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteThreadMemberCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteThreadMemberSignal();
        Q_EMIT deleteThreadMemberSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteThreadMemberSignalE(error_type, error_str);
        Q_EMIT deleteThreadMemberSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteThreadMemberSignalError(error_type, error_str);
        Q_EMIT deleteThreadMemberSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteUserMessageReaction(const QString &channel_id, const QString &message_id, const QString &emoji_name, const QString &user_id) {
    QString fullPath = QString(_serverConfigs["deleteUserMessageReaction"][_serverIndices.value("deleteUserMessageReaction")].URL()+"/channels/{channel_id}/messages/{message_id}/reactions/{emoji_name}/{user_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    
    {
        QString message_idPathParam("{");
        message_idPathParam.append("message_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "message_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"message_id"+pathSuffix : pathPrefix;
        fullPath.replace(message_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(message_id)));
    }
    
    {
        QString emoji_namePathParam("{");
        emoji_namePathParam.append("emoji_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "emoji_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"emoji_name"+pathSuffix : pathPrefix;
        fullPath.replace(emoji_namePathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(emoji_name)));
    }
    
    {
        QString user_idPathParam("{");
        user_idPathParam.append("user_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "user_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"user_id"+pathSuffix : pathPrefix;
        fullPath.replace(user_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(user_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteUserMessageReactionCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteUserMessageReactionCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteUserMessageReactionSignal();
        Q_EMIT deleteUserMessageReactionSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteUserMessageReactionSignalE(error_type, error_str);
        Q_EMIT deleteUserMessageReactionSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteUserMessageReactionSignalError(error_type, error_str);
        Q_EMIT deleteUserMessageReactionSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteWebhook(const QString &webhook_id) {
    QString fullPath = QString(_serverConfigs["deleteWebhook"][_serverIndices.value("deleteWebhook")].URL()+"/webhooks/{webhook_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString webhook_idPathParam("{");
        webhook_idPathParam.append("webhook_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_id"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteWebhookCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteWebhookCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteWebhookSignal();
        Q_EMIT deleteWebhookSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteWebhookSignalE(error_type, error_str);
        Q_EMIT deleteWebhookSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteWebhookSignalError(error_type, error_str);
        Q_EMIT deleteWebhookSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteWebhookByToken(const QString &webhook_id, const QString &webhook_token) {
    QString fullPath = QString(_serverConfigs["deleteWebhookByToken"][_serverIndices.value("deleteWebhookByToken")].URL()+"/webhooks/{webhook_id}/{webhook_token}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString webhook_idPathParam("{");
        webhook_idPathParam.append("webhook_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_id"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_id)));
    }
    
    {
        QString webhook_tokenPathParam("{");
        webhook_tokenPathParam.append("webhook_token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_token"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_tokenPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_token)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteWebhookByTokenCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteWebhookByTokenCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteWebhookByTokenSignal();
        Q_EMIT deleteWebhookByTokenSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteWebhookByTokenSignalE(error_type, error_str);
        Q_EMIT deleteWebhookByTokenSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteWebhookByTokenSignalError(error_type, error_str);
        Q_EMIT deleteWebhookByTokenSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deleteWebhookMessage(const QString &webhook_id, const QString &webhook_token, const QString &message_id, const ::dc_rest::OptionalParam<QString> &thread_id) {
    QString fullPath = QString(_serverConfigs["deleteWebhookMessage"][_serverIndices.value("deleteWebhookMessage")].URL()+"/webhooks/{webhook_id}/{webhook_token}/messages/{message_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString webhook_idPathParam("{");
        webhook_idPathParam.append("webhook_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_id"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_id)));
    }
    
    {
        QString webhook_tokenPathParam("{");
        webhook_tokenPathParam.append("webhook_token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_token"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_tokenPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_token)));
    }
    
    {
        QString message_idPathParam("{");
        message_idPathParam.append("message_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "message_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"message_id"+pathSuffix : pathPrefix;
        fullPath.replace(message_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(message_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (thread_id.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "thread_id", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("thread_id")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(thread_id.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deleteWebhookMessageCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deleteWebhookMessageCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deleteWebhookMessageSignal();
        Q_EMIT deleteWebhookMessageSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deleteWebhookMessageSignalE(error_type, error_str);
        Q_EMIT deleteWebhookMessageSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deleteWebhookMessageSignalError(error_type, error_str);
        Q_EMIT deleteWebhookMessageSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deprecatedCreatePin(const QString &channel_id, const QString &message_id) {
    QString fullPath = QString(_serverConfigs["deprecatedCreatePin"][_serverIndices.value("deprecatedCreatePin")].URL()+"/channels/{channel_id}/pins/{message_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    
    {
        QString message_idPathParam("{");
        message_idPathParam.append("message_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "message_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"message_id"+pathSuffix : pathPrefix;
        fullPath.replace(message_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(message_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deprecatedCreatePinCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deprecatedCreatePinCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deprecatedCreatePinSignal();
        Q_EMIT deprecatedCreatePinSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deprecatedCreatePinSignalE(error_type, error_str);
        Q_EMIT deprecatedCreatePinSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deprecatedCreatePinSignalError(error_type, error_str);
        Q_EMIT deprecatedCreatePinSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deprecatedDeletePin(const QString &channel_id, const QString &message_id) {
    QString fullPath = QString(_serverConfigs["deprecatedDeletePin"][_serverIndices.value("deprecatedDeletePin")].URL()+"/channels/{channel_id}/pins/{message_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    
    {
        QString message_idPathParam("{");
        message_idPathParam.append("message_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "message_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"message_id"+pathSuffix : pathPrefix;
        fullPath.replace(message_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(message_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deprecatedDeletePinCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deprecatedDeletePinCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deprecatedDeletePinSignal();
        Q_EMIT deprecatedDeletePinSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deprecatedDeletePinSignalE(error_type, error_str);
        Q_EMIT deprecatedDeletePinSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deprecatedDeletePinSignalError(error_type, error_str);
        Q_EMIT deprecatedDeletePinSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::deprecatedListPins(const QString &channel_id) {
    QString fullPath = QString(_serverConfigs["deprecatedListPins"][_serverIndices.value("deprecatedListPins")].URL()+"/channels/{channel_id}/pins");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::deprecatedListPinsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::deprecatedListPinsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIMessageResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIMessageResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT deprecatedListPinsSignal(output);
        Q_EMIT deprecatedListPinsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT deprecatedListPinsSignalE(output, error_type, error_str);
        Q_EMIT deprecatedListPinsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT deprecatedListPinsSignalError(output, error_type, error_str);
        Q_EMIT deprecatedListPinsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::editLobby(const QString &lobby_id, const OAICreate_lobby_request &oai_create_lobby_request) {
    QString fullPath = QString(_serverConfigs["editLobby"][_serverIndices.value("editLobby")].URL()+"/lobbies/{lobby_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString lobby_idPathParam("{");
        lobby_idPathParam.append("lobby_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "lobby_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"lobby_id"+pathSuffix : pathPrefix;
        fullPath.replace(lobby_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(lobby_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_create_lobby_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::editLobbyCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::editLobbyCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAILobbyResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT editLobbySignal(output);
        Q_EMIT editLobbySignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT editLobbySignalE(output, error_type, error_str);
        Q_EMIT editLobbySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT editLobbySignalError(output, error_type, error_str);
        Q_EMIT editLobbySignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::editLobbyChannelLink(const QString &lobby_id, const OAIEdit_lobby_channel_link_request &oai_edit_lobby_channel_link_request) {
    QString fullPath = QString(_serverConfigs["editLobbyChannelLink"][_serverIndices.value("editLobbyChannelLink")].URL()+"/lobbies/{lobby_id}/channel-linking");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString lobby_idPathParam("{");
        lobby_idPathParam.append("lobby_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "lobby_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"lobby_id"+pathSuffix : pathPrefix;
        fullPath.replace(lobby_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(lobby_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_edit_lobby_channel_link_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::editLobbyChannelLinkCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::editLobbyChannelLinkCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::editLobbyChannelLinkCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::editLobbyChannelLinkCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::editLobbyChannelLinkCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAILobbyResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT editLobbyChannelLinkSignal(output);
        Q_EMIT editLobbyChannelLinkSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT editLobbyChannelLinkSignalE(output, error_type, error_str);
        Q_EMIT editLobbyChannelLinkSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT editLobbyChannelLinkSignalError(output, error_type, error_str);
        Q_EMIT editLobbyChannelLinkSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::executeGithubCompatibleWebhook(const QString &webhook_id, const QString &webhook_token, const OAIGithubWebhook &oai_github_webhook, const ::dc_rest::OptionalParam<bool> &wait, const ::dc_rest::OptionalParam<QString> &thread_id) {
    QString fullPath = QString(_serverConfigs["executeGithubCompatibleWebhook"][_serverIndices.value("executeGithubCompatibleWebhook")].URL()+"/webhooks/{webhook_id}/{webhook_token}/github");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString webhook_idPathParam("{");
        webhook_idPathParam.append("webhook_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_id"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_id)));
    }
    
    {
        QString webhook_tokenPathParam("{");
        webhook_tokenPathParam.append("webhook_token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_token"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_tokenPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_token)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (wait.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "wait", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("wait")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(wait.stringValue())));
    }
    if (thread_id.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "thread_id", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("thread_id")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(thread_id.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_github_webhook.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::executeGithubCompatibleWebhookCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::executeGithubCompatibleWebhookCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT executeGithubCompatibleWebhookSignal();
        Q_EMIT executeGithubCompatibleWebhookSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT executeGithubCompatibleWebhookSignalE(error_type, error_str);
        Q_EMIT executeGithubCompatibleWebhookSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT executeGithubCompatibleWebhookSignalError(error_type, error_str);
        Q_EMIT executeGithubCompatibleWebhookSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::executeSlackCompatibleWebhook(const QString &webhook_id, const QString &webhook_token, const OAISlackWebhook &oai_slack_webhook, const ::dc_rest::OptionalParam<bool> &wait, const ::dc_rest::OptionalParam<QString> &thread_id) {
    QString fullPath = QString(_serverConfigs["executeSlackCompatibleWebhook"][_serverIndices.value("executeSlackCompatibleWebhook")].URL()+"/webhooks/{webhook_id}/{webhook_token}/slack");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString webhook_idPathParam("{");
        webhook_idPathParam.append("webhook_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_id"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_id)));
    }
    
    {
        QString webhook_tokenPathParam("{");
        webhook_tokenPathParam.append("webhook_token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_token"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_tokenPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_token)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (wait.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "wait", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("wait")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(wait.stringValue())));
    }
    if (thread_id.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "thread_id", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("thread_id")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(thread_id.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_slack_webhook.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::executeSlackCompatibleWebhookCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::executeSlackCompatibleWebhookCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QString output;
    ::dc_rest::fromStringValue(QString(worker->response), output);
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT executeSlackCompatibleWebhookSignal(output);
        Q_EMIT executeSlackCompatibleWebhookSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT executeSlackCompatibleWebhookSignalE(output, error_type, error_str);
        Q_EMIT executeSlackCompatibleWebhookSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT executeSlackCompatibleWebhookSignalError(output, error_type, error_str);
        Q_EMIT executeSlackCompatibleWebhookSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::executeWebhook(const QString &webhook_id, const QString &webhook_token, const OAIExecute_webhook_request &oai_execute_webhook_request, const ::dc_rest::OptionalParam<bool> &wait, const ::dc_rest::OptionalParam<QString> &thread_id, const ::dc_rest::OptionalParam<bool> &with_components) {
    QString fullPath = QString(_serverConfigs["executeWebhook"][_serverIndices.value("executeWebhook")].URL()+"/webhooks/{webhook_id}/{webhook_token}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString webhook_idPathParam("{");
        webhook_idPathParam.append("webhook_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_id"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_id)));
    }
    
    {
        QString webhook_tokenPathParam("{");
        webhook_tokenPathParam.append("webhook_token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_token"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_tokenPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_token)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (wait.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "wait", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("wait")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(wait.stringValue())));
    }
    if (thread_id.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "thread_id", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("thread_id")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(thread_id.stringValue())));
    }
    if (with_components.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "with_components", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("with_components")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(with_components.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_execute_webhook_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::executeWebhookCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::executeWebhookCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessageResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT executeWebhookSignal(output);
        Q_EMIT executeWebhookSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT executeWebhookSignalE(output, error_type, error_str);
        Q_EMIT executeWebhookSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT executeWebhookSignalError(output, error_type, error_str);
        Q_EMIT executeWebhookSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::followChannel(const QString &channel_id, const OAIFollow_channel_request &oai_follow_channel_request) {
    QString fullPath = QString(_serverConfigs["followChannel"][_serverIndices.value("followChannel")].URL()+"/channels/{channel_id}/followers");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_follow_channel_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::followChannelCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::followChannelCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIChannelFollowerResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT followChannelSignal(output);
        Q_EMIT followChannelSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT followChannelSignalE(output, error_type, error_str);
        Q_EMIT followChannelSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT followChannelSignalError(output, error_type, error_str);
        Q_EMIT followChannelSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getActiveGuildThreads(const QString &guild_id) {
    QString fullPath = QString(_serverConfigs["getActiveGuildThreads"][_serverIndices.value("getActiveGuildThreads")].URL()+"/guilds/{guild_id}/threads/active");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getActiveGuildThreadsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getActiveGuildThreadsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIThreadsResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getActiveGuildThreadsSignal(output);
        Q_EMIT getActiveGuildThreadsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getActiveGuildThreadsSignalE(output, error_type, error_str);
        Q_EMIT getActiveGuildThreadsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getActiveGuildThreadsSignalError(output, error_type, error_str);
        Q_EMIT getActiveGuildThreadsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getAnswerVoters(const QString &channel_id, const QString &message_id, const qint32 &answer_id, const ::dc_rest::OptionalParam<QString> &after, const ::dc_rest::OptionalParam<qint32> &limit) {
    QString fullPath = QString(_serverConfigs["getAnswerVoters"][_serverIndices.value("getAnswerVoters")].URL()+"/channels/{channel_id}/polls/{message_id}/answers/{answer_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    
    {
        QString message_idPathParam("{");
        message_idPathParam.append("message_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "message_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"message_id"+pathSuffix : pathPrefix;
        fullPath.replace(message_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(message_id)));
    }
    
    {
        QString answer_idPathParam("{");
        answer_idPathParam.append("answer_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "answer_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"answer_id"+pathSuffix : pathPrefix;
        fullPath.replace(answer_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(answer_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (after.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "after", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("after")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(after.stringValue())));
    }
    if (limit.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(limit.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getAnswerVotersCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getAnswerVotersCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPollAnswerDetailsResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getAnswerVotersSignal(output);
        Q_EMIT getAnswerVotersSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getAnswerVotersSignalE(output, error_type, error_str);
        Q_EMIT getAnswerVotersSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getAnswerVotersSignalError(output, error_type, error_str);
        Q_EMIT getAnswerVotersSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getApplication(const QString &application_id) {
    QString fullPath = QString(_serverConfigs["getApplication"][_serverIndices.value("getApplication")].URL()+"/applications/{application_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getApplicationCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getApplicationCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPrivateApplicationResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getApplicationSignal(output);
        Q_EMIT getApplicationSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getApplicationSignalE(output, error_type, error_str);
        Q_EMIT getApplicationSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getApplicationSignalError(output, error_type, error_str);
        Q_EMIT getApplicationSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getApplicationCommand(const QString &application_id, const QString &command_id) {
    QString fullPath = QString(_serverConfigs["getApplicationCommand"][_serverIndices.value("getApplicationCommand")].URL()+"/applications/{application_id}/commands/{command_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    
    {
        QString command_idPathParam("{");
        command_idPathParam.append("command_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "command_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"command_id"+pathSuffix : pathPrefix;
        fullPath.replace(command_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(command_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("applications.commands.update");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::getApplicationCommandCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIApplicationCommandResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getApplicationCommandSignal(output);
        Q_EMIT getApplicationCommandSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.commands.update");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getApplicationCommandSignalE(output, error_type, error_str);
        Q_EMIT getApplicationCommandSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getApplicationCommandSignalError(output, error_type, error_str);
        Q_EMIT getApplicationCommandSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getApplicationEmoji(const QString &application_id, const QString &emoji_id) {
    QString fullPath = QString(_serverConfigs["getApplicationEmoji"][_serverIndices.value("getApplicationEmoji")].URL()+"/applications/{application_id}/emojis/{emoji_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    
    {
        QString emoji_idPathParam("{");
        emoji_idPathParam.append("emoji_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "emoji_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"emoji_id"+pathSuffix : pathPrefix;
        fullPath.replace(emoji_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(emoji_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getApplicationEmojiCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getApplicationEmojiCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIEmojiResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getApplicationEmojiSignal(output);
        Q_EMIT getApplicationEmojiSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getApplicationEmojiSignalE(output, error_type, error_str);
        Q_EMIT getApplicationEmojiSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getApplicationEmojiSignalError(output, error_type, error_str);
        Q_EMIT getApplicationEmojiSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getApplicationRoleConnectionsMetadata(const QString &application_id) {
    QString fullPath = QString(_serverConfigs["getApplicationRoleConnectionsMetadata"][_serverIndices.value("getApplicationRoleConnectionsMetadata")].URL()+"/applications/{application_id}/role-connections/metadata");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getApplicationRoleConnectionsMetadataCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getApplicationRoleConnectionsMetadataCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIApplicationRoleConnectionsMetadataItemResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIApplicationRoleConnectionsMetadataItemResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getApplicationRoleConnectionsMetadataSignal(output);
        Q_EMIT getApplicationRoleConnectionsMetadataSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getApplicationRoleConnectionsMetadataSignalE(output, error_type, error_str);
        Q_EMIT getApplicationRoleConnectionsMetadataSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getApplicationRoleConnectionsMetadataSignalError(output, error_type, error_str);
        Q_EMIT getApplicationRoleConnectionsMetadataSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getApplicationUserRoleConnection(const QString &application_id) {
    QString fullPath = QString(_serverConfigs["getApplicationUserRoleConnection"][_serverIndices.value("getApplicationUserRoleConnection")].URL()+"/users/@me/applications/{application_id}/role-connection");
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getApplicationUserRoleConnectionCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getApplicationUserRoleConnectionCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getApplicationUserRoleConnectionCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("role_connections.write");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getApplicationUserRoleConnectionCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::getApplicationUserRoleConnectionCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIApplicationUserRoleConnectionResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getApplicationUserRoleConnectionSignal(output);
        Q_EMIT getApplicationUserRoleConnectionSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("role_connections.write");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getApplicationUserRoleConnectionSignalE(output, error_type, error_str);
        Q_EMIT getApplicationUserRoleConnectionSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getApplicationUserRoleConnectionSignalError(output, error_type, error_str);
        Q_EMIT getApplicationUserRoleConnectionSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getAutoModerationRule(const QString &guild_id, const QString &rule_id) {
    QString fullPath = QString(_serverConfigs["getAutoModerationRule"][_serverIndices.value("getAutoModerationRule")].URL()+"/guilds/{guild_id}/auto-moderation/rules/{rule_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString rule_idPathParam("{");
        rule_idPathParam.append("rule_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "rule_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"rule_id"+pathSuffix : pathPrefix;
        fullPath.replace(rule_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(rule_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getAutoModerationRuleCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getAutoModerationRuleCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreate_auto_moderation_rule_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getAutoModerationRuleSignal(output);
        Q_EMIT getAutoModerationRuleSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getAutoModerationRuleSignalE(output, error_type, error_str);
        Q_EMIT getAutoModerationRuleSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getAutoModerationRuleSignalError(output, error_type, error_str);
        Q_EMIT getAutoModerationRuleSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getBotGateway() {
    QString fullPath = QString(_serverConfigs["getBotGateway"][_serverIndices.value("getBotGateway")].URL()+"/gateway/bot");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getBotGatewayCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getBotGatewayCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGatewayBotResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getBotGatewaySignal(output);
        Q_EMIT getBotGatewaySignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getBotGatewaySignalE(output, error_type, error_str);
        Q_EMIT getBotGatewaySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getBotGatewaySignalError(output, error_type, error_str);
        Q_EMIT getBotGatewaySignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getChannel(const QString &channel_id) {
    QString fullPath = QString(_serverConfigs["getChannel"][_serverIndices.value("getChannel")].URL()+"/channels/{channel_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getChannelCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getChannelCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGet_channel_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getChannelSignal(output);
        Q_EMIT getChannelSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getChannelSignalE(output, error_type, error_str);
        Q_EMIT getChannelSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getChannelSignalError(output, error_type, error_str);
        Q_EMIT getChannelSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getEntitlement(const QString &application_id, const QString &entitlement_id) {
    QString fullPath = QString(_serverConfigs["getEntitlement"][_serverIndices.value("getEntitlement")].URL()+"/applications/{application_id}/entitlements/{entitlement_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    
    {
        QString entitlement_idPathParam("{");
        entitlement_idPathParam.append("entitlement_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "entitlement_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"entitlement_id"+pathSuffix : pathPrefix;
        fullPath.replace(entitlement_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(entitlement_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getEntitlementCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    scope.append("applications.entitlements");
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getEntitlementCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("applications.entitlements");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getEntitlementCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("applications.entitlements");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getEntitlementCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::getEntitlementCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIEntitlementResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getEntitlementSignal(output);
        Q_EMIT getEntitlementSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.entitlements");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.entitlements");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.entitlements");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getEntitlementSignalE(output, error_type, error_str);
        Q_EMIT getEntitlementSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getEntitlementSignalError(output, error_type, error_str);
        Q_EMIT getEntitlementSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getEntitlements(const OAIGet_entitlements_sku_ids_parameter &sku_ids, const QString &application_id, const ::dc_rest::OptionalParam<QString> &user_id, const ::dc_rest::OptionalParam<QString> &guild_id, const ::dc_rest::OptionalParam<QString> &before, const ::dc_rest::OptionalParam<QString> &after, const ::dc_rest::OptionalParam<qint32> &limit, const ::dc_rest::OptionalParam<bool> &exclude_ended, const ::dc_rest::OptionalParam<bool> &exclude_deleted, const ::dc_rest::OptionalParam<bool> &only_active) {
    QString fullPath = QString(_serverConfigs["getEntitlements"][_serverIndices.value("getEntitlements")].URL()+"/applications/{application_id}/entitlements");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (user_id.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "user_id", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("user_id")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(user_id.stringValue())));
    }
    
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "sku_ids", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");
        QString paramString = (queryStyle == "form" && true) ? "" : (queryStyle == "form" && !(true)) ? "sku_ids"+querySuffix : "";
        QJsonObject parameter = sku_ids.asJsonObject();
        qint32 count = 0;
        for(const QString& key : parameter.keys()) {
            if (count > 0) {
                queryDelimiter =  ((queryStyle == "form" || queryStyle == "deepObject") && true) ? "&" : getParamStyleDelimiter(queryStyle, key, true);
                paramString.append(queryDelimiter);
            }
            QString assignOperator;
            if (queryStyle == "form")
                assignOperator = (true) ? "=" : ",";
            else if (queryStyle == "deepObject")
                assignOperator = (true) ? "=" : "none";
            switch(parameter.value(key).type()) {
                case QJsonValue::String:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("sku_ids").append("[").append(key).append("]"))+assignOperator+parameter.value(key).toString());
                    break;
                }
                case QJsonValue::Double:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("sku_ids").append("[").append(key).append("]"))+assignOperator+QString::number(parameter.value(key).toDouble()));
                    break;
                }
                case QJsonValue::Bool:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("sku_ids").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toBool()).toString());
                    break;
                }
                case QJsonValue::Array:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("sku_ids").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toArray()).toString());
                    break;
                }
                case QJsonValue::Object:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("sku_ids").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toObject()).toString());
                    break;
                }
                case QJsonValue::Null:
                case QJsonValue::Undefined:
                    break;
            }
            count++;
        }
        fullPath.append(paramString);
            }
    if (guild_id.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "guild_id", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("guild_id")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id.stringValue())));
    }
    if (before.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "before", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("before")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(before.stringValue())));
    }
    if (after.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "after", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("after")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(after.stringValue())));
    }
    if (limit.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(limit.stringValue())));
    }
    if (exclude_ended.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "exclude_ended", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("exclude_ended")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(exclude_ended.stringValue())));
    }
    if (exclude_deleted.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "exclude_deleted", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("exclude_deleted")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(exclude_deleted.stringValue())));
    }
    if (only_active.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "only_active", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("only_active")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(only_active.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getEntitlementsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    scope.append("applications.entitlements");
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getEntitlementsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("applications.entitlements");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getEntitlementsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("applications.entitlements");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getEntitlementsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::getEntitlementsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIEntitlementResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIEntitlementResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getEntitlementsSignal(output);
        Q_EMIT getEntitlementsSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.entitlements");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.entitlements");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.entitlements");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getEntitlementsSignalE(output, error_type, error_str);
        Q_EMIT getEntitlementsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getEntitlementsSignalError(output, error_type, error_str);
        Q_EMIT getEntitlementsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getGateway() {
    QString fullPath = QString(_serverConfigs["getGateway"][_serverIndices.value("getGateway")].URL()+"/gateway");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGatewayCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getGatewayCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGatewayResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGatewaySignal(output);
        Q_EMIT getGatewaySignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGatewaySignalE(output, error_type, error_str);
        Q_EMIT getGatewaySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGatewaySignalError(output, error_type, error_str);
        Q_EMIT getGatewaySignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getGuild(const QString &guild_id, const ::dc_rest::OptionalParam<bool> &with_counts) {
    QString fullPath = QString(_serverConfigs["getGuild"][_serverIndices.value("getGuild")].URL()+"/guilds/{guild_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (with_counts.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "with_counts", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("with_counts")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(with_counts.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGuildCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getGuildCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildWithCountsResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGuildSignal(output);
        Q_EMIT getGuildSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGuildSignalE(output, error_type, error_str);
        Q_EMIT getGuildSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGuildSignalError(output, error_type, error_str);
        Q_EMIT getGuildSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getGuildApplicationCommand(const QString &application_id, const QString &guild_id, const QString &command_id) {
    QString fullPath = QString(_serverConfigs["getGuildApplicationCommand"][_serverIndices.value("getGuildApplicationCommand")].URL()+"/applications/{application_id}/guilds/{guild_id}/commands/{command_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString command_idPathParam("{");
        command_idPathParam.append("command_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "command_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"command_id"+pathSuffix : pathPrefix;
        fullPath.replace(command_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(command_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGuildApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGuildApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("applications.commands.update");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGuildApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGuildApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::getGuildApplicationCommandCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIApplicationCommandResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGuildApplicationCommandSignal(output);
        Q_EMIT getGuildApplicationCommandSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.commands.update");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGuildApplicationCommandSignalE(output, error_type, error_str);
        Q_EMIT getGuildApplicationCommandSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGuildApplicationCommandSignalError(output, error_type, error_str);
        Q_EMIT getGuildApplicationCommandSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getGuildApplicationCommandPermissions(const QString &application_id, const QString &guild_id, const QString &command_id) {
    QString fullPath = QString(_serverConfigs["getGuildApplicationCommandPermissions"][_serverIndices.value("getGuildApplicationCommandPermissions")].URL()+"/applications/{application_id}/guilds/{guild_id}/commands/{command_id}/permissions");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString command_idPathParam("{");
        command_idPathParam.append("command_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "command_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"command_id"+pathSuffix : pathPrefix;
        fullPath.replace(command_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(command_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGuildApplicationCommandPermissionsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    scope.append("applications.commands.permissions.update");
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGuildApplicationCommandPermissionsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("applications.commands.permissions.update");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGuildApplicationCommandPermissionsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("applications.commands.permissions.update");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGuildApplicationCommandPermissionsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::getGuildApplicationCommandPermissionsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICommandPermissionsResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGuildApplicationCommandPermissionsSignal(output);
        Q_EMIT getGuildApplicationCommandPermissionsSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.commands.permissions.update");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.commands.permissions.update");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.commands.permissions.update");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGuildApplicationCommandPermissionsSignalE(output, error_type, error_str);
        Q_EMIT getGuildApplicationCommandPermissionsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGuildApplicationCommandPermissionsSignalError(output, error_type, error_str);
        Q_EMIT getGuildApplicationCommandPermissionsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getGuildBan(const QString &guild_id, const QString &user_id) {
    QString fullPath = QString(_serverConfigs["getGuildBan"][_serverIndices.value("getGuildBan")].URL()+"/guilds/{guild_id}/bans/{user_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString user_idPathParam("{");
        user_idPathParam.append("user_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "user_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"user_id"+pathSuffix : pathPrefix;
        fullPath.replace(user_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(user_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGuildBanCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getGuildBanCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildBanResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGuildBanSignal(output);
        Q_EMIT getGuildBanSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGuildBanSignalE(output, error_type, error_str);
        Q_EMIT getGuildBanSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGuildBanSignalError(output, error_type, error_str);
        Q_EMIT getGuildBanSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getGuildEmoji(const QString &guild_id, const QString &emoji_id) {
    QString fullPath = QString(_serverConfigs["getGuildEmoji"][_serverIndices.value("getGuildEmoji")].URL()+"/guilds/{guild_id}/emojis/{emoji_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString emoji_idPathParam("{");
        emoji_idPathParam.append("emoji_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "emoji_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"emoji_id"+pathSuffix : pathPrefix;
        fullPath.replace(emoji_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(emoji_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGuildEmojiCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getGuildEmojiCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIEmojiResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGuildEmojiSignal(output);
        Q_EMIT getGuildEmojiSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGuildEmojiSignalE(output, error_type, error_str);
        Q_EMIT getGuildEmojiSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGuildEmojiSignalError(output, error_type, error_str);
        Q_EMIT getGuildEmojiSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getGuildMember(const QString &guild_id, const QString &user_id) {
    QString fullPath = QString(_serverConfigs["getGuildMember"][_serverIndices.value("getGuildMember")].URL()+"/guilds/{guild_id}/members/{user_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString user_idPathParam("{");
        user_idPathParam.append("user_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "user_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"user_id"+pathSuffix : pathPrefix;
        fullPath.replace(user_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(user_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGuildMemberCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getGuildMemberCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildMemberResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGuildMemberSignal(output);
        Q_EMIT getGuildMemberSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGuildMemberSignalE(output, error_type, error_str);
        Q_EMIT getGuildMemberSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGuildMemberSignalError(output, error_type, error_str);
        Q_EMIT getGuildMemberSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getGuildNewMemberWelcome(const QString &guild_id) {
    QString fullPath = QString(_serverConfigs["getGuildNewMemberWelcome"][_serverIndices.value("getGuildNewMemberWelcome")].URL()+"/guilds/{guild_id}/new-member-welcome");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGuildNewMemberWelcomeCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getGuildNewMemberWelcomeCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildHomeSettingsResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGuildNewMemberWelcomeSignal(output);
        Q_EMIT getGuildNewMemberWelcomeSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGuildNewMemberWelcomeSignalE(output, error_type, error_str);
        Q_EMIT getGuildNewMemberWelcomeSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGuildNewMemberWelcomeSignalError(output, error_type, error_str);
        Q_EMIT getGuildNewMemberWelcomeSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getGuildPreview(const QString &guild_id) {
    QString fullPath = QString(_serverConfigs["getGuildPreview"][_serverIndices.value("getGuildPreview")].URL()+"/guilds/{guild_id}/preview");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGuildPreviewCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getGuildPreviewCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildPreviewResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGuildPreviewSignal(output);
        Q_EMIT getGuildPreviewSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGuildPreviewSignalE(output, error_type, error_str);
        Q_EMIT getGuildPreviewSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGuildPreviewSignalError(output, error_type, error_str);
        Q_EMIT getGuildPreviewSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getGuildRole(const QString &guild_id, const QString &role_id) {
    QString fullPath = QString(_serverConfigs["getGuildRole"][_serverIndices.value("getGuildRole")].URL()+"/guilds/{guild_id}/roles/{role_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString role_idPathParam("{");
        role_idPathParam.append("role_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "role_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"role_id"+pathSuffix : pathPrefix;
        fullPath.replace(role_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(role_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGuildRoleCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getGuildRoleCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildRoleResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGuildRoleSignal(output);
        Q_EMIT getGuildRoleSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGuildRoleSignalE(output, error_type, error_str);
        Q_EMIT getGuildRoleSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGuildRoleSignalError(output, error_type, error_str);
        Q_EMIT getGuildRoleSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getGuildScheduledEvent(const QString &guild_id, const QString &guild_scheduled_event_id, const ::dc_rest::OptionalParam<bool> &with_user_count) {
    QString fullPath = QString(_serverConfigs["getGuildScheduledEvent"][_serverIndices.value("getGuildScheduledEvent")].URL()+"/guilds/{guild_id}/scheduled-events/{guild_scheduled_event_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString guild_scheduled_event_idPathParam("{");
        guild_scheduled_event_idPathParam.append("guild_scheduled_event_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_scheduled_event_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_scheduled_event_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_scheduled_event_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_scheduled_event_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (with_user_count.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "with_user_count", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("with_user_count")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(with_user_count.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGuildScheduledEventCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getGuildScheduledEventCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIList_guild_scheduled_events_200_response_inner output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGuildScheduledEventSignal(output);
        Q_EMIT getGuildScheduledEventSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGuildScheduledEventSignalE(output, error_type, error_str);
        Q_EMIT getGuildScheduledEventSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGuildScheduledEventSignalError(output, error_type, error_str);
        Q_EMIT getGuildScheduledEventSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getGuildSoundboardSound(const QString &guild_id, const QString &sound_id) {
    QString fullPath = QString(_serverConfigs["getGuildSoundboardSound"][_serverIndices.value("getGuildSoundboardSound")].URL()+"/guilds/{guild_id}/soundboard-sounds/{sound_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString sound_idPathParam("{");
        sound_idPathParam.append("sound_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "sound_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"sound_id"+pathSuffix : pathPrefix;
        fullPath.replace(sound_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(sound_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGuildSoundboardSoundCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getGuildSoundboardSoundCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISoundboardSoundResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGuildSoundboardSoundSignal(output);
        Q_EMIT getGuildSoundboardSoundSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGuildSoundboardSoundSignalE(output, error_type, error_str);
        Q_EMIT getGuildSoundboardSoundSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGuildSoundboardSoundSignalError(output, error_type, error_str);
        Q_EMIT getGuildSoundboardSoundSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getGuildSticker(const QString &guild_id, const QString &sticker_id) {
    QString fullPath = QString(_serverConfigs["getGuildSticker"][_serverIndices.value("getGuildSticker")].URL()+"/guilds/{guild_id}/stickers/{sticker_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString sticker_idPathParam("{");
        sticker_idPathParam.append("sticker_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "sticker_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"sticker_id"+pathSuffix : pathPrefix;
        fullPath.replace(sticker_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(sticker_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGuildStickerCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getGuildStickerCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildStickerResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGuildStickerSignal(output);
        Q_EMIT getGuildStickerSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGuildStickerSignalE(output, error_type, error_str);
        Q_EMIT getGuildStickerSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGuildStickerSignalError(output, error_type, error_str);
        Q_EMIT getGuildStickerSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getGuildTemplate(const QString &code) {
    QString fullPath = QString(_serverConfigs["getGuildTemplate"][_serverIndices.value("getGuildTemplate")].URL()+"/guilds/templates/{code}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString codePathParam("{");
        codePathParam.append("code").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "code", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"code"+pathSuffix : pathPrefix;
        fullPath.replace(codePathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(code)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGuildTemplateCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getGuildTemplateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildTemplateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGuildTemplateSignal(output);
        Q_EMIT getGuildTemplateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGuildTemplateSignalE(output, error_type, error_str);
        Q_EMIT getGuildTemplateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGuildTemplateSignalError(output, error_type, error_str);
        Q_EMIT getGuildTemplateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getGuildVanityUrl(const QString &guild_id) {
    QString fullPath = QString(_serverConfigs["getGuildVanityUrl"][_serverIndices.value("getGuildVanityUrl")].URL()+"/guilds/{guild_id}/vanity-url");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGuildVanityUrlCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getGuildVanityUrlCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIVanityURLResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGuildVanityUrlSignal(output);
        Q_EMIT getGuildVanityUrlSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGuildVanityUrlSignalE(output, error_type, error_str);
        Q_EMIT getGuildVanityUrlSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGuildVanityUrlSignalError(output, error_type, error_str);
        Q_EMIT getGuildVanityUrlSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getGuildWebhooks(const QString &guild_id) {
    QString fullPath = QString(_serverConfigs["getGuildWebhooks"][_serverIndices.value("getGuildWebhooks")].URL()+"/guilds/{guild_id}/webhooks");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGuildWebhooksCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getGuildWebhooksCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIList_channel_webhooks_200_response_inner> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIList_channel_webhooks_200_response_inner val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGuildWebhooksSignal(output);
        Q_EMIT getGuildWebhooksSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGuildWebhooksSignalE(output, error_type, error_str);
        Q_EMIT getGuildWebhooksSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGuildWebhooksSignalError(output, error_type, error_str);
        Q_EMIT getGuildWebhooksSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getGuildWelcomeScreen(const QString &guild_id) {
    QString fullPath = QString(_serverConfigs["getGuildWelcomeScreen"][_serverIndices.value("getGuildWelcomeScreen")].URL()+"/guilds/{guild_id}/welcome-screen");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGuildWelcomeScreenCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getGuildWelcomeScreenCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildWelcomeScreenResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGuildWelcomeScreenSignal(output);
        Q_EMIT getGuildWelcomeScreenSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGuildWelcomeScreenSignalE(output, error_type, error_str);
        Q_EMIT getGuildWelcomeScreenSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGuildWelcomeScreenSignalError(output, error_type, error_str);
        Q_EMIT getGuildWelcomeScreenSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getGuildWidget(const QString &guild_id) {
    QString fullPath = QString(_serverConfigs["getGuildWidget"][_serverIndices.value("getGuildWidget")].URL()+"/guilds/{guild_id}/widget.json");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGuildWidgetCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getGuildWidgetCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWidgetResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGuildWidgetSignal(output);
        Q_EMIT getGuildWidgetSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGuildWidgetSignalE(output, error_type, error_str);
        Q_EMIT getGuildWidgetSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGuildWidgetSignalError(output, error_type, error_str);
        Q_EMIT getGuildWidgetSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getGuildWidgetPng(const QString &guild_id, const ::dc_rest::OptionalParam<QString> &style) {
    QString fullPath = QString(_serverConfigs["getGuildWidgetPng"][_serverIndices.value("getGuildWidgetPng")].URL()+"/guilds/{guild_id}/widget.png");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (style.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "style", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("style")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(style.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGuildWidgetPngCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getGuildWidgetPngCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QString output;
    ::dc_rest::fromStringValue(QString(worker->response), output);
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGuildWidgetPngSignal(output);
        Q_EMIT getGuildWidgetPngSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGuildWidgetPngSignalE(output, error_type, error_str);
        Q_EMIT getGuildWidgetPngSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGuildWidgetPngSignalError(output, error_type, error_str);
        Q_EMIT getGuildWidgetPngSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getGuildWidgetSettings(const QString &guild_id) {
    QString fullPath = QString(_serverConfigs["getGuildWidgetSettings"][_serverIndices.value("getGuildWidgetSettings")].URL()+"/guilds/{guild_id}/widget");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGuildWidgetSettingsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getGuildWidgetSettingsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWidgetSettingsResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGuildWidgetSettingsSignal(output);
        Q_EMIT getGuildWidgetSettingsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGuildWidgetSettingsSignalE(output, error_type, error_str);
        Q_EMIT getGuildWidgetSettingsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGuildWidgetSettingsSignalError(output, error_type, error_str);
        Q_EMIT getGuildWidgetSettingsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getGuildsOnboarding(const QString &guild_id) {
    QString fullPath = QString(_serverConfigs["getGuildsOnboarding"][_serverIndices.value("getGuildsOnboarding")].URL()+"/guilds/{guild_id}/onboarding");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getGuildsOnboardingCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getGuildsOnboardingCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIUserGuildOnboardingResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getGuildsOnboardingSignal(output);
        Q_EMIT getGuildsOnboardingSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getGuildsOnboardingSignalE(output, error_type, error_str);
        Q_EMIT getGuildsOnboardingSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getGuildsOnboardingSignalError(output, error_type, error_str);
        Q_EMIT getGuildsOnboardingSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getLobby(const QString &lobby_id) {
    QString fullPath = QString(_serverConfigs["getLobby"][_serverIndices.value("getLobby")].URL()+"/lobbies/{lobby_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString lobby_idPathParam("{");
        lobby_idPathParam.append("lobby_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "lobby_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"lobby_id"+pathSuffix : pathPrefix;
        fullPath.replace(lobby_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(lobby_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getLobbyCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getLobbyCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAILobbyResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getLobbySignal(output);
        Q_EMIT getLobbySignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getLobbySignalE(output, error_type, error_str);
        Q_EMIT getLobbySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getLobbySignalError(output, error_type, error_str);
        Q_EMIT getLobbySignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getLobbyMessages(const QString &lobby_id, const ::dc_rest::OptionalParam<qint32> &limit) {
    QString fullPath = QString(_serverConfigs["getLobbyMessages"][_serverIndices.value("getLobbyMessages")].URL()+"/lobbies/{lobby_id}/messages");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString lobby_idPathParam("{");
        lobby_idPathParam.append("lobby_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "lobby_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"lobby_id"+pathSuffix : pathPrefix;
        fullPath.replace(lobby_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(lobby_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (limit.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(limit.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getLobbyMessagesCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getLobbyMessagesCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getLobbyMessagesCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getLobbyMessagesCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::getLobbyMessagesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAILobbyMessageResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAILobbyMessageResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getLobbyMessagesSignal(output);
        Q_EMIT getLobbyMessagesSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getLobbyMessagesSignalE(output, error_type, error_str);
        Q_EMIT getLobbyMessagesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getLobbyMessagesSignalError(output, error_type, error_str);
        Q_EMIT getLobbyMessagesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getMessage(const QString &channel_id, const QString &message_id) {
    QString fullPath = QString(_serverConfigs["getMessage"][_serverIndices.value("getMessage")].URL()+"/channels/{channel_id}/messages/{message_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    
    {
        QString message_idPathParam("{");
        message_idPathParam.append("message_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "message_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"message_id"+pathSuffix : pathPrefix;
        fullPath.replace(message_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(message_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getMessageCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getMessageCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessageResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getMessageSignal(output);
        Q_EMIT getMessageSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getMessageSignalE(output, error_type, error_str);
        Q_EMIT getMessageSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getMessageSignalError(output, error_type, error_str);
        Q_EMIT getMessageSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getMyApplication() {
    QString fullPath = QString(_serverConfigs["getMyApplication"][_serverIndices.value("getMyApplication")].URL()+"/applications/@me");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getMyApplicationCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getMyApplicationCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPrivateApplicationResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getMyApplicationSignal(output);
        Q_EMIT getMyApplicationSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getMyApplicationSignalE(output, error_type, error_str);
        Q_EMIT getMyApplicationSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getMyApplicationSignalError(output, error_type, error_str);
        Q_EMIT getMyApplicationSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getMyGuildMember(const QString &guild_id) {
    QString fullPath = QString(_serverConfigs["getMyGuildMember"][_serverIndices.value("getMyGuildMember")].URL()+"/users/@me/guilds/{guild_id}/member");
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getMyGuildMemberCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    scope.append("guilds.members.read");
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getMyGuildMemberCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("guilds.members.read");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getMyGuildMemberCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("guilds.members.read");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getMyGuildMemberCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::getMyGuildMemberCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPrivateGuildMemberResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getMyGuildMemberSignal(output);
        Q_EMIT getMyGuildMemberSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("guilds.members.read");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("guilds.members.read");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("guilds.members.read");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getMyGuildMemberSignalE(output, error_type, error_str);
        Q_EMIT getMyGuildMemberSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getMyGuildMemberSignalError(output, error_type, error_str);
        Q_EMIT getMyGuildMemberSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getMyOauth2Application() {
    QString fullPath = QString(_serverConfigs["getMyOauth2Application"][_serverIndices.value("getMyOauth2Application")].URL()+"/oauth2/applications/@me");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getMyOauth2ApplicationCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getMyOauth2ApplicationCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPrivateApplicationResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getMyOauth2ApplicationSignal(output);
        Q_EMIT getMyOauth2ApplicationSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getMyOauth2ApplicationSignalE(output, error_type, error_str);
        Q_EMIT getMyOauth2ApplicationSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getMyOauth2ApplicationSignalError(output, error_type, error_str);
        Q_EMIT getMyOauth2ApplicationSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getMyOauth2Authorization() {
    QString fullPath = QString(_serverConfigs["getMyOauth2Authorization"][_serverIndices.value("getMyOauth2Authorization")].URL()+"/oauth2/@me");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getMyOauth2AuthorizationCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    scope.append("activities.invites.write");
    scope.append("activities.read");
    scope.append("activities.write");
    scope.append("applications.builds.read");
    scope.append("applications.builds.upload");
    scope.append("applications.commands");
    scope.append("applications.commands.permissions.update");
    scope.append("applications.entitlements");
    scope.append("applications.store.update");
    scope.append("bot");
    scope.append("connections");
    scope.append("dm_channels.read");
    scope.append("email");
    scope.append("gdm.join");
    scope.append("guilds");
    scope.append("guilds.join");
    scope.append("guilds.members.read");
    scope.append("identify");
    scope.append("messages.read");
    scope.append("openid");
    scope.append("relationships.read");
    scope.append("rpc");
    scope.append("rpc.activities.write");
    scope.append("rpc.notifications.read");
    scope.append("rpc.screenshare.read");
    scope.append("rpc.screenshare.write");
    scope.append("rpc.video.read");
    scope.append("rpc.video.write");
    scope.append("rpc.voice.read");
    scope.append("rpc.voice.write");
    scope.append("voice");
    scope.append("webhook.incoming");
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getMyOauth2AuthorizationCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("activities.invites.write");
    scope.append("activities.read");
    scope.append("activities.write");
    scope.append("applications.builds.read");
    scope.append("applications.builds.upload");
    scope.append("applications.commands");
    scope.append("applications.commands.permissions.update");
    scope.append("applications.commands.update");
    scope.append("applications.entitlements");
    scope.append("applications.store.update");
    scope.append("bot");
    scope.append("connections");
    scope.append("dm_channels.read");
    scope.append("email");
    scope.append("gdm.join");
    scope.append("guilds");
    scope.append("guilds.join");
    scope.append("guilds.members.read");
    scope.append("identify");
    scope.append("messages.read");
    scope.append("openid");
    scope.append("relationships.read");
    scope.append("rpc");
    scope.append("rpc.activities.write");
    scope.append("rpc.notifications.read");
    scope.append("rpc.screenshare.read");
    scope.append("rpc.screenshare.write");
    scope.append("rpc.video.read");
    scope.append("rpc.video.write");
    scope.append("rpc.voice.read");
    scope.append("rpc.voice.write");
    scope.append("voice");
    scope.append("webhook.incoming");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getMyOauth2AuthorizationCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("activities.invites.write");
    scope.append("activities.read");
    scope.append("activities.write");
    scope.append("applications.builds.read");
    scope.append("applications.builds.upload");
    scope.append("applications.commands");
    scope.append("applications.commands.permissions.update");
    scope.append("applications.entitlements");
    scope.append("applications.store.update");
    scope.append("bot");
    scope.append("connections");
    scope.append("dm_channels.read");
    scope.append("email");
    scope.append("gdm.join");
    scope.append("guilds");
    scope.append("guilds.join");
    scope.append("guilds.members.read");
    scope.append("identify");
    scope.append("messages.read");
    scope.append("openid");
    scope.append("relationships.read");
    scope.append("role_connections.write");
    scope.append("rpc");
    scope.append("rpc.activities.write");
    scope.append("rpc.notifications.read");
    scope.append("rpc.screenshare.read");
    scope.append("rpc.screenshare.write");
    scope.append("rpc.video.read");
    scope.append("rpc.video.write");
    scope.append("rpc.voice.read");
    scope.append("rpc.voice.write");
    scope.append("voice");
    scope.append("webhook.incoming");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getMyOauth2AuthorizationCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::getMyOauth2AuthorizationCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIOAuth2GetAuthorizationResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getMyOauth2AuthorizationSignal(output);
        Q_EMIT getMyOauth2AuthorizationSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("activities.invites.write");
        scope.append("activities.read");
        scope.append("activities.write");
        scope.append("applications.builds.read");
        scope.append("applications.builds.upload");
        scope.append("applications.commands");
        scope.append("applications.commands.permissions.update");
        scope.append("applications.entitlements");
        scope.append("applications.store.update");
        scope.append("bot");
        scope.append("connections");
        scope.append("dm_channels.read");
        scope.append("email");
        scope.append("gdm.join");
        scope.append("guilds");
        scope.append("guilds.join");
        scope.append("guilds.members.read");
        scope.append("identify");
        scope.append("messages.read");
        scope.append("openid");
        scope.append("relationships.read");
        scope.append("rpc");
        scope.append("rpc.activities.write");
        scope.append("rpc.notifications.read");
        scope.append("rpc.screenshare.read");
        scope.append("rpc.screenshare.write");
        scope.append("rpc.video.read");
        scope.append("rpc.video.write");
        scope.append("rpc.voice.read");
        scope.append("rpc.voice.write");
        scope.append("voice");
        scope.append("webhook.incoming");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("activities.invites.write");
        scope.append("activities.read");
        scope.append("activities.write");
        scope.append("applications.builds.read");
        scope.append("applications.builds.upload");
        scope.append("applications.commands");
        scope.append("applications.commands.permissions.update");
        scope.append("applications.commands.update");
        scope.append("applications.entitlements");
        scope.append("applications.store.update");
        scope.append("bot");
        scope.append("connections");
        scope.append("dm_channels.read");
        scope.append("email");
        scope.append("gdm.join");
        scope.append("guilds");
        scope.append("guilds.join");
        scope.append("guilds.members.read");
        scope.append("identify");
        scope.append("messages.read");
        scope.append("openid");
        scope.append("relationships.read");
        scope.append("rpc");
        scope.append("rpc.activities.write");
        scope.append("rpc.notifications.read");
        scope.append("rpc.screenshare.read");
        scope.append("rpc.screenshare.write");
        scope.append("rpc.video.read");
        scope.append("rpc.video.write");
        scope.append("rpc.voice.read");
        scope.append("rpc.voice.write");
        scope.append("voice");
        scope.append("webhook.incoming");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("activities.invites.write");
        scope.append("activities.read");
        scope.append("activities.write");
        scope.append("applications.builds.read");
        scope.append("applications.builds.upload");
        scope.append("applications.commands");
        scope.append("applications.commands.permissions.update");
        scope.append("applications.entitlements");
        scope.append("applications.store.update");
        scope.append("bot");
        scope.append("connections");
        scope.append("dm_channels.read");
        scope.append("email");
        scope.append("gdm.join");
        scope.append("guilds");
        scope.append("guilds.join");
        scope.append("guilds.members.read");
        scope.append("identify");
        scope.append("messages.read");
        scope.append("openid");
        scope.append("relationships.read");
        scope.append("role_connections.write");
        scope.append("rpc");
        scope.append("rpc.activities.write");
        scope.append("rpc.notifications.read");
        scope.append("rpc.screenshare.read");
        scope.append("rpc.screenshare.write");
        scope.append("rpc.video.read");
        scope.append("rpc.video.write");
        scope.append("rpc.voice.read");
        scope.append("rpc.voice.write");
        scope.append("voice");
        scope.append("webhook.incoming");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getMyOauth2AuthorizationSignalE(output, error_type, error_str);
        Q_EMIT getMyOauth2AuthorizationSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getMyOauth2AuthorizationSignalError(output, error_type, error_str);
        Q_EMIT getMyOauth2AuthorizationSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getMyUser() {
    QString fullPath = QString(_serverConfigs["getMyUser"][_serverIndices.value("getMyUser")].URL()+"/users/@me");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getMyUserCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    scope.append("identify");
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getMyUserCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("identify");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getMyUserCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("identify");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getMyUserCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::getMyUserCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIUserPIIResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getMyUserSignal(output);
        Q_EMIT getMyUserSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("identify");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("identify");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("identify");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getMyUserSignalE(output, error_type, error_str);
        Q_EMIT getMyUserSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getMyUserSignalError(output, error_type, error_str);
        Q_EMIT getMyUserSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getOpenidConnectUserinfo() {
    QString fullPath = QString(_serverConfigs["getOpenidConnectUserinfo"][_serverIndices.value("getOpenidConnectUserinfo")].URL()+"/oauth2/userinfo");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getOpenidConnectUserinfoCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    scope.append("openid");
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getOpenidConnectUserinfoCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("openid");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getOpenidConnectUserinfoCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("openid");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getOpenidConnectUserinfoCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::getOpenidConnectUserinfoCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIOAuth2GetOpenIDConnectUserInfoResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getOpenidConnectUserinfoSignal(output);
        Q_EMIT getOpenidConnectUserinfoSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("openid");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("openid");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("openid");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getOpenidConnectUserinfoSignalE(output, error_type, error_str);
        Q_EMIT getOpenidConnectUserinfoSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getOpenidConnectUserinfoSignalError(output, error_type, error_str);
        Q_EMIT getOpenidConnectUserinfoSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getOriginalWebhookMessage(const QString &webhook_id, const QString &webhook_token, const ::dc_rest::OptionalParam<QString> &thread_id) {
    QString fullPath = QString(_serverConfigs["getOriginalWebhookMessage"][_serverIndices.value("getOriginalWebhookMessage")].URL()+"/webhooks/{webhook_id}/{webhook_token}/messages/@original");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString webhook_idPathParam("{");
        webhook_idPathParam.append("webhook_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_id"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_id)));
    }
    
    {
        QString webhook_tokenPathParam("{");
        webhook_tokenPathParam.append("webhook_token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_token"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_tokenPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_token)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (thread_id.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "thread_id", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("thread_id")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(thread_id.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getOriginalWebhookMessageCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getOriginalWebhookMessageCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessageResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getOriginalWebhookMessageSignal(output);
        Q_EMIT getOriginalWebhookMessageSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getOriginalWebhookMessageSignalE(output, error_type, error_str);
        Q_EMIT getOriginalWebhookMessageSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getOriginalWebhookMessageSignalError(output, error_type, error_str);
        Q_EMIT getOriginalWebhookMessageSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getPublicKeys() {
    QString fullPath = QString(_serverConfigs["getPublicKeys"][_serverIndices.value("getPublicKeys")].URL()+"/oauth2/keys");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getPublicKeysCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getPublicKeysCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIOAuth2GetKeys output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getPublicKeysSignal(output);
        Q_EMIT getPublicKeysSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getPublicKeysSignalE(output, error_type, error_str);
        Q_EMIT getPublicKeysSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getPublicKeysSignalError(output, error_type, error_str);
        Q_EMIT getPublicKeysSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getSelfVoiceState(const QString &guild_id) {
    QString fullPath = QString(_serverConfigs["getSelfVoiceState"][_serverIndices.value("getSelfVoiceState")].URL()+"/guilds/{guild_id}/voice-states/@me");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getSelfVoiceStateCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getSelfVoiceStateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIVoiceStateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSelfVoiceStateSignal(output);
        Q_EMIT getSelfVoiceStateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSelfVoiceStateSignalE(output, error_type, error_str);
        Q_EMIT getSelfVoiceStateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSelfVoiceStateSignalError(output, error_type, error_str);
        Q_EMIT getSelfVoiceStateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getSoundboardDefaultSounds() {
    QString fullPath = QString(_serverConfigs["getSoundboardDefaultSounds"][_serverIndices.value("getSoundboardDefaultSounds")].URL()+"/soundboard-default-sounds");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getSoundboardDefaultSoundsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getSoundboardDefaultSoundsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAISoundboardSoundResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAISoundboardSoundResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getSoundboardDefaultSoundsSignal(output);
        Q_EMIT getSoundboardDefaultSoundsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getSoundboardDefaultSoundsSignalE(output, error_type, error_str);
        Q_EMIT getSoundboardDefaultSoundsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getSoundboardDefaultSoundsSignalError(output, error_type, error_str);
        Q_EMIT getSoundboardDefaultSoundsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getStageInstance(const QString &channel_id) {
    QString fullPath = QString(_serverConfigs["getStageInstance"][_serverIndices.value("getStageInstance")].URL()+"/stage-instances/{channel_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getStageInstanceCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getStageInstanceCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStageInstanceResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getStageInstanceSignal(output);
        Q_EMIT getStageInstanceSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getStageInstanceSignalE(output, error_type, error_str);
        Q_EMIT getStageInstanceSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getStageInstanceSignalError(output, error_type, error_str);
        Q_EMIT getStageInstanceSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getSticker(const QString &sticker_id) {
    QString fullPath = QString(_serverConfigs["getSticker"][_serverIndices.value("getSticker")].URL()+"/stickers/{sticker_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString sticker_idPathParam("{");
        sticker_idPathParam.append("sticker_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "sticker_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"sticker_id"+pathSuffix : pathPrefix;
        fullPath.replace(sticker_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(sticker_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getStickerCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getStickerCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGet_sticker_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getStickerSignal(output);
        Q_EMIT getStickerSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getStickerSignalE(output, error_type, error_str);
        Q_EMIT getStickerSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getStickerSignalError(output, error_type, error_str);
        Q_EMIT getStickerSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getStickerPack(const QString &pack_id) {
    QString fullPath = QString(_serverConfigs["getStickerPack"][_serverIndices.value("getStickerPack")].URL()+"/sticker-packs/{pack_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString pack_idPathParam("{");
        pack_idPathParam.append("pack_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "pack_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"pack_id"+pathSuffix : pathPrefix;
        fullPath.replace(pack_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(pack_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getStickerPackCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getStickerPackCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStickerPackResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getStickerPackSignal(output);
        Q_EMIT getStickerPackSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getStickerPackSignalE(output, error_type, error_str);
        Q_EMIT getStickerPackSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getStickerPackSignalError(output, error_type, error_str);
        Q_EMIT getStickerPackSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getThreadMember(const QString &channel_id, const QString &user_id, const ::dc_rest::OptionalParam<bool> &with_member) {
    QString fullPath = QString(_serverConfigs["getThreadMember"][_serverIndices.value("getThreadMember")].URL()+"/channels/{channel_id}/thread-members/{user_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    
    {
        QString user_idPathParam("{");
        user_idPathParam.append("user_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "user_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"user_id"+pathSuffix : pathPrefix;
        fullPath.replace(user_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(user_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (with_member.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "with_member", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("with_member")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(with_member.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getThreadMemberCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getThreadMemberCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIThreadMemberResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getThreadMemberSignal(output);
        Q_EMIT getThreadMemberSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getThreadMemberSignalE(output, error_type, error_str);
        Q_EMIT getThreadMemberSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getThreadMemberSignalError(output, error_type, error_str);
        Q_EMIT getThreadMemberSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getUser(const QString &user_id) {
    QString fullPath = QString(_serverConfigs["getUser"][_serverIndices.value("getUser")].URL()+"/users/{user_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString user_idPathParam("{");
        user_idPathParam.append("user_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "user_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"user_id"+pathSuffix : pathPrefix;
        fullPath.replace(user_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(user_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getUserCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getUserCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIUserResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getUserSignal(output);
        Q_EMIT getUserSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getUserSignalE(output, error_type, error_str);
        Q_EMIT getUserSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getUserSignalError(output, error_type, error_str);
        Q_EMIT getUserSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getVoiceState(const QString &guild_id, const QString &user_id) {
    QString fullPath = QString(_serverConfigs["getVoiceState"][_serverIndices.value("getVoiceState")].URL()+"/guilds/{guild_id}/voice-states/{user_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString user_idPathParam("{");
        user_idPathParam.append("user_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "user_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"user_id"+pathSuffix : pathPrefix;
        fullPath.replace(user_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(user_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getVoiceStateCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getVoiceStateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIVoiceStateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getVoiceStateSignal(output);
        Q_EMIT getVoiceStateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getVoiceStateSignalE(output, error_type, error_str);
        Q_EMIT getVoiceStateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getVoiceStateSignalError(output, error_type, error_str);
        Q_EMIT getVoiceStateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getWebhook(const QString &webhook_id) {
    QString fullPath = QString(_serverConfigs["getWebhook"][_serverIndices.value("getWebhook")].URL()+"/webhooks/{webhook_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString webhook_idPathParam("{");
        webhook_idPathParam.append("webhook_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_id"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getWebhookCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getWebhookCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIList_channel_webhooks_200_response_inner output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getWebhookSignal(output);
        Q_EMIT getWebhookSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getWebhookSignalE(output, error_type, error_str);
        Q_EMIT getWebhookSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getWebhookSignalError(output, error_type, error_str);
        Q_EMIT getWebhookSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getWebhookByToken(const QString &webhook_id, const QString &webhook_token) {
    QString fullPath = QString(_serverConfigs["getWebhookByToken"][_serverIndices.value("getWebhookByToken")].URL()+"/webhooks/{webhook_id}/{webhook_token}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString webhook_idPathParam("{");
        webhook_idPathParam.append("webhook_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_id"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_id)));
    }
    
    {
        QString webhook_tokenPathParam("{");
        webhook_tokenPathParam.append("webhook_token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_token"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_tokenPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_token)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getWebhookByTokenCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getWebhookByTokenCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIList_channel_webhooks_200_response_inner output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getWebhookByTokenSignal(output);
        Q_EMIT getWebhookByTokenSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getWebhookByTokenSignalE(output, error_type, error_str);
        Q_EMIT getWebhookByTokenSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getWebhookByTokenSignalError(output, error_type, error_str);
        Q_EMIT getWebhookByTokenSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::getWebhookMessage(const QString &webhook_id, const QString &webhook_token, const QString &message_id, const ::dc_rest::OptionalParam<QString> &thread_id) {
    QString fullPath = QString(_serverConfigs["getWebhookMessage"][_serverIndices.value("getWebhookMessage")].URL()+"/webhooks/{webhook_id}/{webhook_token}/messages/{message_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString webhook_idPathParam("{");
        webhook_idPathParam.append("webhook_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_id"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_id)));
    }
    
    {
        QString webhook_tokenPathParam("{");
        webhook_tokenPathParam.append("webhook_token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_token"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_tokenPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_token)));
    }
    
    {
        QString message_idPathParam("{");
        message_idPathParam.append("message_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "message_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"message_id"+pathSuffix : pathPrefix;
        fullPath.replace(message_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(message_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (thread_id.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "thread_id", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("thread_id")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(thread_id.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::getWebhookMessageCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::getWebhookMessageCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessageResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT getWebhookMessageSignal(output);
        Q_EMIT getWebhookMessageSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT getWebhookMessageSignalE(output, error_type, error_str);
        Q_EMIT getWebhookMessageSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT getWebhookMessageSignalError(output, error_type, error_str);
        Q_EMIT getWebhookMessageSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::inviteResolve(const QString &code, const ::dc_rest::OptionalParam<bool> &with_counts, const ::dc_rest::OptionalParam<QString> &guild_scheduled_event_id) {
    QString fullPath = QString(_serverConfigs["inviteResolve"][_serverIndices.value("inviteResolve")].URL()+"/invites/{code}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString codePathParam("{");
        codePathParam.append("code").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "code", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"code"+pathSuffix : pathPrefix;
        fullPath.replace(codePathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(code)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (with_counts.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "with_counts", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("with_counts")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(with_counts.stringValue())));
    }
    if (guild_scheduled_event_id.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "guild_scheduled_event_id", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("guild_scheduled_event_id")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_scheduled_event_id.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::inviteResolveCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::inviteResolveCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIList_channel_invites_200_response_inner output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT inviteResolveSignal(output);
        Q_EMIT inviteResolveSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT inviteResolveSignalE(output, error_type, error_str);
        Q_EMIT inviteResolveSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT inviteResolveSignalError(output, error_type, error_str);
        Q_EMIT inviteResolveSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::inviteRevoke(const QString &code) {
    QString fullPath = QString(_serverConfigs["inviteRevoke"][_serverIndices.value("inviteRevoke")].URL()+"/invites/{code}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString codePathParam("{");
        codePathParam.append("code").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "code", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"code"+pathSuffix : pathPrefix;
        fullPath.replace(codePathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(code)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::inviteRevokeCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::inviteRevokeCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIList_channel_invites_200_response_inner output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT inviteRevokeSignal(output);
        Q_EMIT inviteRevokeSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT inviteRevokeSignalE(output, error_type, error_str);
        Q_EMIT inviteRevokeSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT inviteRevokeSignalError(output, error_type, error_str);
        Q_EMIT inviteRevokeSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::joinThread(const QString &channel_id) {
    QString fullPath = QString(_serverConfigs["joinThread"][_serverIndices.value("joinThread")].URL()+"/channels/{channel_id}/thread-members/@me");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::joinThreadCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::joinThreadCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT joinThreadSignal();
        Q_EMIT joinThreadSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT joinThreadSignalE(error_type, error_str);
        Q_EMIT joinThreadSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT joinThreadSignalError(error_type, error_str);
        Q_EMIT joinThreadSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::leaveGuild(const QString &guild_id) {
    QString fullPath = QString(_serverConfigs["leaveGuild"][_serverIndices.value("leaveGuild")].URL()+"/users/@me/guilds/{guild_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::leaveGuildCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::leaveGuildCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT leaveGuildSignal();
        Q_EMIT leaveGuildSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT leaveGuildSignalE(error_type, error_str);
        Q_EMIT leaveGuildSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT leaveGuildSignalError(error_type, error_str);
        Q_EMIT leaveGuildSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::leaveLobby(const QString &lobby_id) {
    QString fullPath = QString(_serverConfigs["leaveLobby"][_serverIndices.value("leaveLobby")].URL()+"/lobbies/{lobby_id}/members/@me");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString lobby_idPathParam("{");
        lobby_idPathParam.append("lobby_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "lobby_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"lobby_id"+pathSuffix : pathPrefix;
        fullPath.replace(lobby_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(lobby_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::leaveLobbyCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::leaveLobbyCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::leaveLobbyCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::leaveLobbyCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::leaveLobbyCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT leaveLobbySignal();
        Q_EMIT leaveLobbySignalFull(worker);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT leaveLobbySignalE(error_type, error_str);
        Q_EMIT leaveLobbySignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT leaveLobbySignalError(error_type, error_str);
        Q_EMIT leaveLobbySignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::leaveThread(const QString &channel_id) {
    QString fullPath = QString(_serverConfigs["leaveThread"][_serverIndices.value("leaveThread")].URL()+"/channels/{channel_id}/thread-members/@me");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::leaveThreadCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::leaveThreadCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT leaveThreadSignal();
        Q_EMIT leaveThreadSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT leaveThreadSignalE(error_type, error_str);
        Q_EMIT leaveThreadSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT leaveThreadSignalError(error_type, error_str);
        Q_EMIT leaveThreadSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listApplicationCommands(const QString &application_id, const ::dc_rest::OptionalParam<bool> &with_localizations) {
    QString fullPath = QString(_serverConfigs["listApplicationCommands"][_serverIndices.value("listApplicationCommands")].URL()+"/applications/{application_id}/commands");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (with_localizations.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "with_localizations", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("with_localizations")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(with_localizations.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listApplicationCommandsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listApplicationCommandsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("applications.commands.update");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listApplicationCommandsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listApplicationCommandsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::listApplicationCommandsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIApplicationCommandResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIApplicationCommandResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listApplicationCommandsSignal(output);
        Q_EMIT listApplicationCommandsSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.commands.update");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listApplicationCommandsSignalE(output, error_type, error_str);
        Q_EMIT listApplicationCommandsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listApplicationCommandsSignalError(output, error_type, error_str);
        Q_EMIT listApplicationCommandsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listApplicationEmojis(const QString &application_id) {
    QString fullPath = QString(_serverConfigs["listApplicationEmojis"][_serverIndices.value("listApplicationEmojis")].URL()+"/applications/{application_id}/emojis");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listApplicationEmojisCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::listApplicationEmojisCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIListApplicationEmojisResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listApplicationEmojisSignal(output);
        Q_EMIT listApplicationEmojisSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listApplicationEmojisSignalE(output, error_type, error_str);
        Q_EMIT listApplicationEmojisSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listApplicationEmojisSignalError(output, error_type, error_str);
        Q_EMIT listApplicationEmojisSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listAutoModerationRules(const QString &guild_id) {
    QString fullPath = QString(_serverConfigs["listAutoModerationRules"][_serverIndices.value("listAutoModerationRules")].URL()+"/guilds/{guild_id}/auto-moderation/rules");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listAutoModerationRulesCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::listAutoModerationRulesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIList_auto_moderation_rules_200_response_inner> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIList_auto_moderation_rules_200_response_inner val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listAutoModerationRulesSignal(output);
        Q_EMIT listAutoModerationRulesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listAutoModerationRulesSignalE(output, error_type, error_str);
        Q_EMIT listAutoModerationRulesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listAutoModerationRulesSignalError(output, error_type, error_str);
        Q_EMIT listAutoModerationRulesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listChannelInvites(const QString &channel_id) {
    QString fullPath = QString(_serverConfigs["listChannelInvites"][_serverIndices.value("listChannelInvites")].URL()+"/channels/{channel_id}/invites");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listChannelInvitesCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::listChannelInvitesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIList_channel_invites_200_response_inner> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIList_channel_invites_200_response_inner val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listChannelInvitesSignal(output);
        Q_EMIT listChannelInvitesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listChannelInvitesSignalE(output, error_type, error_str);
        Q_EMIT listChannelInvitesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listChannelInvitesSignalError(output, error_type, error_str);
        Q_EMIT listChannelInvitesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listChannelWebhooks(const QString &channel_id) {
    QString fullPath = QString(_serverConfigs["listChannelWebhooks"][_serverIndices.value("listChannelWebhooks")].URL()+"/channels/{channel_id}/webhooks");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listChannelWebhooksCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::listChannelWebhooksCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIList_channel_webhooks_200_response_inner> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIList_channel_webhooks_200_response_inner val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listChannelWebhooksSignal(output);
        Q_EMIT listChannelWebhooksSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listChannelWebhooksSignalE(output, error_type, error_str);
        Q_EMIT listChannelWebhooksSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listChannelWebhooksSignalError(output, error_type, error_str);
        Q_EMIT listChannelWebhooksSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listGuildApplicationCommandPermissions(const QString &application_id, const QString &guild_id) {
    QString fullPath = QString(_serverConfigs["listGuildApplicationCommandPermissions"][_serverIndices.value("listGuildApplicationCommandPermissions")].URL()+"/applications/{application_id}/guilds/{guild_id}/commands/permissions");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listGuildApplicationCommandPermissionsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    scope.append("applications.commands.permissions.update");
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listGuildApplicationCommandPermissionsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("applications.commands.permissions.update");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listGuildApplicationCommandPermissionsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("applications.commands.permissions.update");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listGuildApplicationCommandPermissionsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::listGuildApplicationCommandPermissionsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAICommandPermissionsResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAICommandPermissionsResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listGuildApplicationCommandPermissionsSignal(output);
        Q_EMIT listGuildApplicationCommandPermissionsSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.commands.permissions.update");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.commands.permissions.update");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.commands.permissions.update");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listGuildApplicationCommandPermissionsSignalE(output, error_type, error_str);
        Q_EMIT listGuildApplicationCommandPermissionsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listGuildApplicationCommandPermissionsSignalError(output, error_type, error_str);
        Q_EMIT listGuildApplicationCommandPermissionsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listGuildApplicationCommands(const QString &application_id, const QString &guild_id, const ::dc_rest::OptionalParam<bool> &with_localizations) {
    QString fullPath = QString(_serverConfigs["listGuildApplicationCommands"][_serverIndices.value("listGuildApplicationCommands")].URL()+"/applications/{application_id}/guilds/{guild_id}/commands");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (with_localizations.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "with_localizations", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("with_localizations")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(with_localizations.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listGuildApplicationCommandsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listGuildApplicationCommandsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("applications.commands.update");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listGuildApplicationCommandsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listGuildApplicationCommandsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::listGuildApplicationCommandsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIApplicationCommandResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIApplicationCommandResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listGuildApplicationCommandsSignal(output);
        Q_EMIT listGuildApplicationCommandsSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.commands.update");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listGuildApplicationCommandsSignalE(output, error_type, error_str);
        Q_EMIT listGuildApplicationCommandsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listGuildApplicationCommandsSignalError(output, error_type, error_str);
        Q_EMIT listGuildApplicationCommandsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listGuildAuditLogEntries(const QString &guild_id, const ::dc_rest::OptionalParam<QString> &user_id, const ::dc_rest::OptionalParam<QString> &target_id, const ::dc_rest::OptionalParam<qint32> &action_type, const ::dc_rest::OptionalParam<QString> &before, const ::dc_rest::OptionalParam<QString> &after, const ::dc_rest::OptionalParam<qint32> &limit) {
    QString fullPath = QString(_serverConfigs["listGuildAuditLogEntries"][_serverIndices.value("listGuildAuditLogEntries")].URL()+"/guilds/{guild_id}/audit-logs");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (user_id.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "user_id", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("user_id")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(user_id.stringValue())));
    }
    if (target_id.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "target_id", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("target_id")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(target_id.stringValue())));
    }
    if (action_type.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "action_type", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("action_type")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(action_type.stringValue())));
    }
    if (before.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "before", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("before")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(before.stringValue())));
    }
    if (after.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "after", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("after")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(after.stringValue())));
    }
    if (limit.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(limit.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listGuildAuditLogEntriesCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::listGuildAuditLogEntriesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildAuditLogResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listGuildAuditLogEntriesSignal(output);
        Q_EMIT listGuildAuditLogEntriesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listGuildAuditLogEntriesSignalE(output, error_type, error_str);
        Q_EMIT listGuildAuditLogEntriesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listGuildAuditLogEntriesSignalError(output, error_type, error_str);
        Q_EMIT listGuildAuditLogEntriesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listGuildBans(const QString &guild_id, const ::dc_rest::OptionalParam<qint32> &limit, const ::dc_rest::OptionalParam<QString> &before, const ::dc_rest::OptionalParam<QString> &after) {
    QString fullPath = QString(_serverConfigs["listGuildBans"][_serverIndices.value("listGuildBans")].URL()+"/guilds/{guild_id}/bans");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (limit.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(limit.stringValue())));
    }
    if (before.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "before", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("before")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(before.stringValue())));
    }
    if (after.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "after", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("after")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(after.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listGuildBansCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::listGuildBansCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIGuildBanResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIGuildBanResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listGuildBansSignal(output);
        Q_EMIT listGuildBansSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listGuildBansSignalE(output, error_type, error_str);
        Q_EMIT listGuildBansSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listGuildBansSignalError(output, error_type, error_str);
        Q_EMIT listGuildBansSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listGuildChannels(const QString &guild_id) {
    QString fullPath = QString(_serverConfigs["listGuildChannels"][_serverIndices.value("listGuildChannels")].URL()+"/guilds/{guild_id}/channels");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listGuildChannelsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listGuildChannelsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listGuildChannelsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listGuildChannelsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::listGuildChannelsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIGet_channel_200_response> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIGet_channel_200_response val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listGuildChannelsSignal(output);
        Q_EMIT listGuildChannelsSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listGuildChannelsSignalE(output, error_type, error_str);
        Q_EMIT listGuildChannelsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listGuildChannelsSignalError(output, error_type, error_str);
        Q_EMIT listGuildChannelsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listGuildEmojis(const QString &guild_id) {
    QString fullPath = QString(_serverConfigs["listGuildEmojis"][_serverIndices.value("listGuildEmojis")].URL()+"/guilds/{guild_id}/emojis");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listGuildEmojisCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::listGuildEmojisCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIEmojiResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIEmojiResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listGuildEmojisSignal(output);
        Q_EMIT listGuildEmojisSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listGuildEmojisSignalE(output, error_type, error_str);
        Q_EMIT listGuildEmojisSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listGuildEmojisSignalError(output, error_type, error_str);
        Q_EMIT listGuildEmojisSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listGuildIntegrations(const QString &guild_id) {
    QString fullPath = QString(_serverConfigs["listGuildIntegrations"][_serverIndices.value("listGuildIntegrations")].URL()+"/guilds/{guild_id}/integrations");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listGuildIntegrationsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::listGuildIntegrationsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIList_guild_integrations_200_response_inner> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIList_guild_integrations_200_response_inner val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listGuildIntegrationsSignal(output);
        Q_EMIT listGuildIntegrationsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listGuildIntegrationsSignalE(output, error_type, error_str);
        Q_EMIT listGuildIntegrationsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listGuildIntegrationsSignalError(output, error_type, error_str);
        Q_EMIT listGuildIntegrationsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listGuildInvites(const QString &guild_id) {
    QString fullPath = QString(_serverConfigs["listGuildInvites"][_serverIndices.value("listGuildInvites")].URL()+"/guilds/{guild_id}/invites");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listGuildInvitesCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::listGuildInvitesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIList_channel_invites_200_response_inner> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIList_channel_invites_200_response_inner val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listGuildInvitesSignal(output);
        Q_EMIT listGuildInvitesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listGuildInvitesSignalE(output, error_type, error_str);
        Q_EMIT listGuildInvitesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listGuildInvitesSignalError(output, error_type, error_str);
        Q_EMIT listGuildInvitesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listGuildMembers(const QString &guild_id, const ::dc_rest::OptionalParam<qint32> &limit, const ::dc_rest::OptionalParam<qint32> &after) {
    QString fullPath = QString(_serverConfigs["listGuildMembers"][_serverIndices.value("listGuildMembers")].URL()+"/guilds/{guild_id}/members");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (limit.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(limit.stringValue())));
    }
    if (after.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "after", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("after")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(after.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listGuildMembersCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::listGuildMembersCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIGuildMemberResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIGuildMemberResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listGuildMembersSignal(output);
        Q_EMIT listGuildMembersSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listGuildMembersSignalE(output, error_type, error_str);
        Q_EMIT listGuildMembersSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listGuildMembersSignalError(output, error_type, error_str);
        Q_EMIT listGuildMembersSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listGuildRoles(const QString &guild_id) {
    QString fullPath = QString(_serverConfigs["listGuildRoles"][_serverIndices.value("listGuildRoles")].URL()+"/guilds/{guild_id}/roles");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listGuildRolesCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::listGuildRolesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIGuildRoleResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIGuildRoleResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listGuildRolesSignal(output);
        Q_EMIT listGuildRolesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listGuildRolesSignalE(output, error_type, error_str);
        Q_EMIT listGuildRolesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listGuildRolesSignalError(output, error_type, error_str);
        Q_EMIT listGuildRolesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listGuildScheduledEventUsers(const QString &guild_id, const QString &guild_scheduled_event_id, const ::dc_rest::OptionalParam<bool> &with_member, const ::dc_rest::OptionalParam<qint32> &limit, const ::dc_rest::OptionalParam<QString> &before, const ::dc_rest::OptionalParam<QString> &after) {
    QString fullPath = QString(_serverConfigs["listGuildScheduledEventUsers"][_serverIndices.value("listGuildScheduledEventUsers")].URL()+"/guilds/{guild_id}/scheduled-events/{guild_scheduled_event_id}/users");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString guild_scheduled_event_idPathParam("{");
        guild_scheduled_event_idPathParam.append("guild_scheduled_event_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_scheduled_event_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_scheduled_event_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_scheduled_event_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_scheduled_event_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (with_member.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "with_member", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("with_member")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(with_member.stringValue())));
    }
    if (limit.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(limit.stringValue())));
    }
    if (before.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "before", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("before")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(before.stringValue())));
    }
    if (after.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "after", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("after")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(after.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listGuildScheduledEventUsersCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::listGuildScheduledEventUsersCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIScheduledEventUserResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIScheduledEventUserResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listGuildScheduledEventUsersSignal(output);
        Q_EMIT listGuildScheduledEventUsersSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listGuildScheduledEventUsersSignalE(output, error_type, error_str);
        Q_EMIT listGuildScheduledEventUsersSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listGuildScheduledEventUsersSignalError(output, error_type, error_str);
        Q_EMIT listGuildScheduledEventUsersSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listGuildScheduledEvents(const QString &guild_id, const ::dc_rest::OptionalParam<bool> &with_user_count) {
    QString fullPath = QString(_serverConfigs["listGuildScheduledEvents"][_serverIndices.value("listGuildScheduledEvents")].URL()+"/guilds/{guild_id}/scheduled-events");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (with_user_count.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "with_user_count", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("with_user_count")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(with_user_count.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listGuildScheduledEventsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::listGuildScheduledEventsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIList_guild_scheduled_events_200_response_inner> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIList_guild_scheduled_events_200_response_inner val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listGuildScheduledEventsSignal(output);
        Q_EMIT listGuildScheduledEventsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listGuildScheduledEventsSignalE(output, error_type, error_str);
        Q_EMIT listGuildScheduledEventsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listGuildScheduledEventsSignalError(output, error_type, error_str);
        Q_EMIT listGuildScheduledEventsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listGuildSoundboardSounds(const QString &guild_id) {
    QString fullPath = QString(_serverConfigs["listGuildSoundboardSounds"][_serverIndices.value("listGuildSoundboardSounds")].URL()+"/guilds/{guild_id}/soundboard-sounds");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listGuildSoundboardSoundsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::listGuildSoundboardSoundsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIListGuildSoundboardSoundsResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listGuildSoundboardSoundsSignal(output);
        Q_EMIT listGuildSoundboardSoundsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listGuildSoundboardSoundsSignalE(output, error_type, error_str);
        Q_EMIT listGuildSoundboardSoundsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listGuildSoundboardSoundsSignalError(output, error_type, error_str);
        Q_EMIT listGuildSoundboardSoundsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listGuildStickers(const QString &guild_id) {
    QString fullPath = QString(_serverConfigs["listGuildStickers"][_serverIndices.value("listGuildStickers")].URL()+"/guilds/{guild_id}/stickers");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listGuildStickersCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::listGuildStickersCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIGuildStickerResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIGuildStickerResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listGuildStickersSignal(output);
        Q_EMIT listGuildStickersSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listGuildStickersSignalE(output, error_type, error_str);
        Q_EMIT listGuildStickersSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listGuildStickersSignalError(output, error_type, error_str);
        Q_EMIT listGuildStickersSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listGuildTemplates(const QString &guild_id) {
    QString fullPath = QString(_serverConfigs["listGuildTemplates"][_serverIndices.value("listGuildTemplates")].URL()+"/guilds/{guild_id}/templates");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listGuildTemplatesCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::listGuildTemplatesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIGuildTemplateResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIGuildTemplateResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listGuildTemplatesSignal(output);
        Q_EMIT listGuildTemplatesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listGuildTemplatesSignalE(output, error_type, error_str);
        Q_EMIT listGuildTemplatesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listGuildTemplatesSignalError(output, error_type, error_str);
        Q_EMIT listGuildTemplatesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listGuildVoiceRegions(const QString &guild_id) {
    QString fullPath = QString(_serverConfigs["listGuildVoiceRegions"][_serverIndices.value("listGuildVoiceRegions")].URL()+"/guilds/{guild_id}/regions");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listGuildVoiceRegionsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::listGuildVoiceRegionsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIVoiceRegionResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIVoiceRegionResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listGuildVoiceRegionsSignal(output);
        Q_EMIT listGuildVoiceRegionsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listGuildVoiceRegionsSignalE(output, error_type, error_str);
        Q_EMIT listGuildVoiceRegionsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listGuildVoiceRegionsSignalError(output, error_type, error_str);
        Q_EMIT listGuildVoiceRegionsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listMessageReactionsByEmoji(const QString &channel_id, const QString &message_id, const QString &emoji_name, const ::dc_rest::OptionalParam<QString> &after, const ::dc_rest::OptionalParam<qint32> &limit, const ::dc_rest::OptionalParam<qint32> &type) {
    QString fullPath = QString(_serverConfigs["listMessageReactionsByEmoji"][_serverIndices.value("listMessageReactionsByEmoji")].URL()+"/channels/{channel_id}/messages/{message_id}/reactions/{emoji_name}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    
    {
        QString message_idPathParam("{");
        message_idPathParam.append("message_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "message_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"message_id"+pathSuffix : pathPrefix;
        fullPath.replace(message_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(message_id)));
    }
    
    {
        QString emoji_namePathParam("{");
        emoji_namePathParam.append("emoji_name").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "emoji_name", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"emoji_name"+pathSuffix : pathPrefix;
        fullPath.replace(emoji_namePathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(emoji_name)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (after.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "after", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("after")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(after.stringValue())));
    }
    if (limit.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(limit.stringValue())));
    }
    if (type.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "type", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("type")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(type.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listMessageReactionsByEmojiCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::listMessageReactionsByEmojiCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIUserResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIUserResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listMessageReactionsByEmojiSignal(output);
        Q_EMIT listMessageReactionsByEmojiSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listMessageReactionsByEmojiSignalE(output, error_type, error_str);
        Q_EMIT listMessageReactionsByEmojiSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listMessageReactionsByEmojiSignalError(output, error_type, error_str);
        Q_EMIT listMessageReactionsByEmojiSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listMessages(const QString &channel_id, const ::dc_rest::OptionalParam<QString> &around, const ::dc_rest::OptionalParam<QString> &before, const ::dc_rest::OptionalParam<QString> &after, const ::dc_rest::OptionalParam<qint32> &limit) {
    QString fullPath = QString(_serverConfigs["listMessages"][_serverIndices.value("listMessages")].URL()+"/channels/{channel_id}/messages");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (around.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "around", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("around")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(around.stringValue())));
    }
    if (before.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "before", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("before")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(before.stringValue())));
    }
    if (after.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "after", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("after")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(after.stringValue())));
    }
    if (limit.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(limit.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listMessagesCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::listMessagesCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIMessageResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIMessageResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listMessagesSignal(output);
        Q_EMIT listMessagesSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listMessagesSignalE(output, error_type, error_str);
        Q_EMIT listMessagesSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listMessagesSignalError(output, error_type, error_str);
        Q_EMIT listMessagesSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listMyConnections() {
    QString fullPath = QString(_serverConfigs["listMyConnections"][_serverIndices.value("listMyConnections")].URL()+"/users/@me/connections");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listMyConnectionsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    scope.append("connections");
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listMyConnectionsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("connections");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listMyConnectionsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("connections");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listMyConnectionsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::listMyConnectionsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIConnectedAccountResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIConnectedAccountResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listMyConnectionsSignal(output);
        Q_EMIT listMyConnectionsSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("connections");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("connections");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("connections");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listMyConnectionsSignalE(output, error_type, error_str);
        Q_EMIT listMyConnectionsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listMyConnectionsSignalError(output, error_type, error_str);
        Q_EMIT listMyConnectionsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listMyGuilds(const ::dc_rest::OptionalParam<QString> &before, const ::dc_rest::OptionalParam<QString> &after, const ::dc_rest::OptionalParam<qint32> &limit, const ::dc_rest::OptionalParam<bool> &with_counts) {
    QString fullPath = QString(_serverConfigs["listMyGuilds"][_serverIndices.value("listMyGuilds")].URL()+"/users/@me/guilds");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (before.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "before", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("before")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(before.stringValue())));
    }
    if (after.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "after", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("after")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(after.stringValue())));
    }
    if (limit.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(limit.stringValue())));
    }
    if (with_counts.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "with_counts", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("with_counts")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(with_counts.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listMyGuildsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    scope.append("guilds");
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listMyGuildsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("guilds");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listMyGuildsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("guilds");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listMyGuildsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::listMyGuildsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIMyGuildResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIMyGuildResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listMyGuildsSignal(output);
        Q_EMIT listMyGuildsSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("guilds");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("guilds");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("guilds");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listMyGuildsSignalE(output, error_type, error_str);
        Q_EMIT listMyGuildsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listMyGuildsSignalError(output, error_type, error_str);
        Q_EMIT listMyGuildsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listMyPrivateArchivedThreads(const QString &channel_id, const ::dc_rest::OptionalParam<QString> &before, const ::dc_rest::OptionalParam<qint32> &limit) {
    QString fullPath = QString(_serverConfigs["listMyPrivateArchivedThreads"][_serverIndices.value("listMyPrivateArchivedThreads")].URL()+"/channels/{channel_id}/users/@me/threads/archived/private");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (before.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "before", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("before")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(before.stringValue())));
    }
    if (limit.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(limit.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listMyPrivateArchivedThreadsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::listMyPrivateArchivedThreadsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIThreadsResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listMyPrivateArchivedThreadsSignal(output);
        Q_EMIT listMyPrivateArchivedThreadsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listMyPrivateArchivedThreadsSignalE(output, error_type, error_str);
        Q_EMIT listMyPrivateArchivedThreadsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listMyPrivateArchivedThreadsSignalError(output, error_type, error_str);
        Q_EMIT listMyPrivateArchivedThreadsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listPins(const QString &channel_id, const ::dc_rest::OptionalParam<QDateTime> &before, const ::dc_rest::OptionalParam<qint32> &limit) {
    QString fullPath = QString(_serverConfigs["listPins"][_serverIndices.value("listPins")].URL()+"/channels/{channel_id}/messages/pins");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (before.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "before", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("before")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(before.stringValue())));
    }
    if (limit.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(limit.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listPinsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::listPinsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPinnedMessagesResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listPinsSignal(output);
        Q_EMIT listPinsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listPinsSignalE(output, error_type, error_str);
        Q_EMIT listPinsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listPinsSignalError(output, error_type, error_str);
        Q_EMIT listPinsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listPrivateArchivedThreads(const QString &channel_id, const ::dc_rest::OptionalParam<QDateTime> &before, const ::dc_rest::OptionalParam<qint32> &limit) {
    QString fullPath = QString(_serverConfigs["listPrivateArchivedThreads"][_serverIndices.value("listPrivateArchivedThreads")].URL()+"/channels/{channel_id}/threads/archived/private");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (before.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "before", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("before")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(before.stringValue())));
    }
    if (limit.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(limit.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listPrivateArchivedThreadsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::listPrivateArchivedThreadsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIThreadsResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listPrivateArchivedThreadsSignal(output);
        Q_EMIT listPrivateArchivedThreadsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listPrivateArchivedThreadsSignalE(output, error_type, error_str);
        Q_EMIT listPrivateArchivedThreadsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listPrivateArchivedThreadsSignalError(output, error_type, error_str);
        Q_EMIT listPrivateArchivedThreadsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listPublicArchivedThreads(const QString &channel_id, const ::dc_rest::OptionalParam<QDateTime> &before, const ::dc_rest::OptionalParam<qint32> &limit) {
    QString fullPath = QString(_serverConfigs["listPublicArchivedThreads"][_serverIndices.value("listPublicArchivedThreads")].URL()+"/channels/{channel_id}/threads/archived/public");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (before.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "before", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("before")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(before.stringValue())));
    }
    if (limit.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(limit.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listPublicArchivedThreadsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::listPublicArchivedThreadsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIThreadsResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listPublicArchivedThreadsSignal(output);
        Q_EMIT listPublicArchivedThreadsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listPublicArchivedThreadsSignalE(output, error_type, error_str);
        Q_EMIT listPublicArchivedThreadsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listPublicArchivedThreadsSignalError(output, error_type, error_str);
        Q_EMIT listPublicArchivedThreadsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listStickerPacks() {
    QString fullPath = QString(_serverConfigs["listStickerPacks"][_serverIndices.value("listStickerPacks")].URL()+"/sticker-packs");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listStickerPacksCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::listStickerPacksCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStickerPackCollectionResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listStickerPacksSignal(output);
        Q_EMIT listStickerPacksSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listStickerPacksSignalE(output, error_type, error_str);
        Q_EMIT listStickerPacksSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listStickerPacksSignalError(output, error_type, error_str);
        Q_EMIT listStickerPacksSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listThreadMembers(const QString &channel_id, const ::dc_rest::OptionalParam<bool> &with_member, const ::dc_rest::OptionalParam<qint32> &limit, const ::dc_rest::OptionalParam<QString> &after) {
    QString fullPath = QString(_serverConfigs["listThreadMembers"][_serverIndices.value("listThreadMembers")].URL()+"/channels/{channel_id}/thread-members");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (with_member.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "with_member", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("with_member")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(with_member.stringValue())));
    }
    if (limit.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(limit.stringValue())));
    }
    if (after.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "after", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("after")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(after.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listThreadMembersCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::listThreadMembersCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIThreadMemberResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIThreadMemberResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listThreadMembersSignal(output);
        Q_EMIT listThreadMembersSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listThreadMembersSignalE(output, error_type, error_str);
        Q_EMIT listThreadMembersSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listThreadMembersSignalError(output, error_type, error_str);
        Q_EMIT listThreadMembersSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::listVoiceRegions() {
    QString fullPath = QString(_serverConfigs["listVoiceRegions"][_serverIndices.value("listVoiceRegions")].URL()+"/voice/regions");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::listVoiceRegionsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::listVoiceRegionsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIVoiceRegionResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIVoiceRegionResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT listVoiceRegionsSignal(output);
        Q_EMIT listVoiceRegionsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT listVoiceRegionsSignalE(output, error_type, error_str);
        Q_EMIT listVoiceRegionsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT listVoiceRegionsSignalError(output, error_type, error_str);
        Q_EMIT listVoiceRegionsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::partnerSdkToken(const OAIPartner_sdk_unmerge_provisional_account_request &oai_partner_sdk_unmerge_provisional_account_request) {
    QString fullPath = QString(_serverConfigs["partnerSdkToken"][_serverIndices.value("partnerSdkToken")].URL()+"/partner-sdk/token");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_partner_sdk_unmerge_provisional_account_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::partnerSdkTokenCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::partnerSdkTokenCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIProvisionalTokenResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT partnerSdkTokenSignal(output);
        Q_EMIT partnerSdkTokenSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT partnerSdkTokenSignalE(output, error_type, error_str);
        Q_EMIT partnerSdkTokenSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT partnerSdkTokenSignalError(output, error_type, error_str);
        Q_EMIT partnerSdkTokenSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::partnerSdkUnmergeProvisionalAccount(const OAIPartner_sdk_unmerge_provisional_account_request &oai_partner_sdk_unmerge_provisional_account_request) {
    QString fullPath = QString(_serverConfigs["partnerSdkUnmergeProvisionalAccount"][_serverIndices.value("partnerSdkUnmergeProvisionalAccount")].URL()+"/partner-sdk/provisional-accounts/unmerge");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_partner_sdk_unmerge_provisional_account_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::partnerSdkUnmergeProvisionalAccountCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::partnerSdkUnmergeProvisionalAccountCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT partnerSdkUnmergeProvisionalAccountSignal();
        Q_EMIT partnerSdkUnmergeProvisionalAccountSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT partnerSdkUnmergeProvisionalAccountSignalE(error_type, error_str);
        Q_EMIT partnerSdkUnmergeProvisionalAccountSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT partnerSdkUnmergeProvisionalAccountSignalError(error_type, error_str);
        Q_EMIT partnerSdkUnmergeProvisionalAccountSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::pollExpire(const QString &channel_id, const QString &message_id) {
    QString fullPath = QString(_serverConfigs["pollExpire"][_serverIndices.value("pollExpire")].URL()+"/channels/{channel_id}/polls/{message_id}/expire");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    
    {
        QString message_idPathParam("{");
        message_idPathParam.append("message_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "message_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"message_id"+pathSuffix : pathPrefix;
        fullPath.replace(message_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(message_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::pollExpireCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::pollExpireCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessageResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT pollExpireSignal(output);
        Q_EMIT pollExpireSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT pollExpireSignalE(output, error_type, error_str);
        Q_EMIT pollExpireSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT pollExpireSignalError(output, error_type, error_str);
        Q_EMIT pollExpireSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::previewPruneGuild(const QString &guild_id, const ::dc_rest::OptionalParam<qint32> &days, const ::dc_rest::OptionalParam<OAIGet_entitlements_sku_ids_parameter> &include_roles) {
    QString fullPath = QString(_serverConfigs["previewPruneGuild"][_serverIndices.value("previewPruneGuild")].URL()+"/guilds/{guild_id}/prune");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (days.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "days", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("days")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(days.stringValue())));
    }
    if (include_roles.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "include_roles", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");
        QString paramString = (queryStyle == "form" && true) ? "" : (queryStyle == "form" && !(true)) ? "include_roles"+querySuffix : "";
        QJsonObject parameter = include_roles.value().asJsonObject();
        qint32 count = 0;
        for(const QString& key : parameter.keys()) {
            if (count > 0) {
                queryDelimiter =  ((queryStyle == "form" || queryStyle == "deepObject") && true) ? "&" : getParamStyleDelimiter(queryStyle, key, true);
                paramString.append(queryDelimiter);
            }
            QString assignOperator;
            if (queryStyle == "form")
                assignOperator = (true) ? "=" : ",";
            else if (queryStyle == "deepObject")
                assignOperator = (true) ? "=" : "none";
            switch(parameter.value(key).type()) {
                case QJsonValue::String:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("include_roles").append("[").append(key).append("]"))+assignOperator+parameter.value(key).toString());
                    break;
                }
                case QJsonValue::Double:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("include_roles").append("[").append(key).append("]"))+assignOperator+QString::number(parameter.value(key).toDouble()));
                    break;
                }
                case QJsonValue::Bool:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("include_roles").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toBool()).toString());
                    break;
                }
                case QJsonValue::Array:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("include_roles").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toArray()).toString());
                    break;
                }
                case QJsonValue::Object:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("include_roles").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toObject()).toString());
                    break;
                }
                case QJsonValue::Null:
                case QJsonValue::Undefined:
                    break;
            }
            count++;
        }
        fullPath.append(paramString);
            }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::previewPruneGuildCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::previewPruneGuildCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildPruneResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT previewPruneGuildSignal(output);
        Q_EMIT previewPruneGuildSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT previewPruneGuildSignalE(output, error_type, error_str);
        Q_EMIT previewPruneGuildSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT previewPruneGuildSignalError(output, error_type, error_str);
        Q_EMIT previewPruneGuildSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::pruneGuild(const QString &guild_id, const OAIPrune_guild_request &oai_prune_guild_request) {
    QString fullPath = QString(_serverConfigs["pruneGuild"][_serverIndices.value("pruneGuild")].URL()+"/guilds/{guild_id}/prune");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_prune_guild_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::pruneGuildCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::pruneGuildCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildPruneResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT pruneGuildSignal(output);
        Q_EMIT pruneGuildSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT pruneGuildSignalE(output, error_type, error_str);
        Q_EMIT pruneGuildSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT pruneGuildSignalError(output, error_type, error_str);
        Q_EMIT pruneGuildSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::putGuildsOnboarding(const QString &guild_id, const OAIUpdateGuildOnboardingRequest &oai_update_guild_onboarding_request) {
    QString fullPath = QString(_serverConfigs["putGuildsOnboarding"][_serverIndices.value("putGuildsOnboarding")].URL()+"/guilds/{guild_id}/onboarding");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_update_guild_onboarding_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::putGuildsOnboardingCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::putGuildsOnboardingCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildOnboardingResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT putGuildsOnboardingSignal(output);
        Q_EMIT putGuildsOnboardingSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT putGuildsOnboardingSignalE(output, error_type, error_str);
        Q_EMIT putGuildsOnboardingSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT putGuildsOnboardingSignalError(output, error_type, error_str);
        Q_EMIT putGuildsOnboardingSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::searchGuildMembers(const qint32 &limit, const QString &query, const QString &guild_id) {
    QString fullPath = QString(_serverConfigs["searchGuildMembers"][_serverIndices.value("searchGuildMembers")].URL()+"/guilds/{guild_id}/members/search");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(limit)));
    }
    
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "query", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("query")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(query)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::searchGuildMembersCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::searchGuildMembersCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIGuildMemberResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIGuildMemberResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT searchGuildMembersSignal(output);
        Q_EMIT searchGuildMembersSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT searchGuildMembersSignalE(output, error_type, error_str);
        Q_EMIT searchGuildMembersSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT searchGuildMembersSignalError(output, error_type, error_str);
        Q_EMIT searchGuildMembersSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::sendSoundboardSound(const QString &channel_id, const OAISoundboardSoundSendRequest &oai_soundboard_sound_send_request) {
    QString fullPath = QString(_serverConfigs["sendSoundboardSound"][_serverIndices.value("sendSoundboardSound")].URL()+"/channels/{channel_id}/send-soundboard-sound");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_soundboard_sound_send_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::sendSoundboardSoundCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::sendSoundboardSoundCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT sendSoundboardSoundSignal();
        Q_EMIT sendSoundboardSoundSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT sendSoundboardSoundSignalE(error_type, error_str);
        Q_EMIT sendSoundboardSoundSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT sendSoundboardSoundSignalError(error_type, error_str);
        Q_EMIT sendSoundboardSoundSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setChannelPermissionOverwrite(const QString &channel_id, const QString &overwrite_id, const OAISet_channel_permission_overwrite_request &oai_set_channel_permission_overwrite_request) {
    QString fullPath = QString(_serverConfigs["setChannelPermissionOverwrite"][_serverIndices.value("setChannelPermissionOverwrite")].URL()+"/channels/{channel_id}/permissions/{overwrite_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    
    {
        QString overwrite_idPathParam("{");
        overwrite_idPathParam.append("overwrite_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "overwrite_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"overwrite_id"+pathSuffix : pathPrefix;
        fullPath.replace(overwrite_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(overwrite_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_set_channel_permission_overwrite_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setChannelPermissionOverwriteCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setChannelPermissionOverwriteCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT setChannelPermissionOverwriteSignal();
        Q_EMIT setChannelPermissionOverwriteSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT setChannelPermissionOverwriteSignalE(error_type, error_str);
        Q_EMIT setChannelPermissionOverwriteSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT setChannelPermissionOverwriteSignalError(error_type, error_str);
        Q_EMIT setChannelPermissionOverwriteSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setGuildApplicationCommandPermissions(const QString &application_id, const QString &guild_id, const QString &command_id, const OAISet_guild_application_command_permissions_request &oai_set_guild_application_command_permissions_request) {
    QString fullPath = QString(_serverConfigs["setGuildApplicationCommandPermissions"][_serverIndices.value("setGuildApplicationCommandPermissions")].URL()+"/applications/{application_id}/guilds/{guild_id}/commands/{command_id}/permissions");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString command_idPathParam("{");
        command_idPathParam.append("command_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "command_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"command_id"+pathSuffix : pathPrefix;
        fullPath.replace(command_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(command_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_set_guild_application_command_permissions_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setGuildApplicationCommandPermissionsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    scope.append("applications.commands.permissions.update");
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setGuildApplicationCommandPermissionsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("applications.commands.permissions.update");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setGuildApplicationCommandPermissionsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("applications.commands.permissions.update");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setGuildApplicationCommandPermissionsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::setGuildApplicationCommandPermissionsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICommandPermissionsResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT setGuildApplicationCommandPermissionsSignal(output);
        Q_EMIT setGuildApplicationCommandPermissionsSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.commands.permissions.update");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.commands.permissions.update");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.commands.permissions.update");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT setGuildApplicationCommandPermissionsSignalE(output, error_type, error_str);
        Q_EMIT setGuildApplicationCommandPermissionsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT setGuildApplicationCommandPermissionsSignalError(output, error_type, error_str);
        Q_EMIT setGuildApplicationCommandPermissionsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::setGuildMfaLevel(const QString &guild_id, const OAISet_guild_mfa_level_request &oai_set_guild_mfa_level_request) {
    QString fullPath = QString(_serverConfigs["setGuildMfaLevel"][_serverIndices.value("setGuildMfaLevel")].URL()+"/guilds/{guild_id}/mfa");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    {

        
        QByteArray output = oai_set_guild_mfa_level_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::setGuildMfaLevelCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::setGuildMfaLevelCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildMFALevelResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT setGuildMfaLevelSignal(output);
        Q_EMIT setGuildMfaLevelSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT setGuildMfaLevelSignalE(output, error_type, error_str);
        Q_EMIT setGuildMfaLevelSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT setGuildMfaLevelSignalError(output, error_type, error_str);
        Q_EMIT setGuildMfaLevelSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::syncGuildTemplate(const QString &guild_id, const QString &code) {
    QString fullPath = QString(_serverConfigs["syncGuildTemplate"][_serverIndices.value("syncGuildTemplate")].URL()+"/guilds/{guild_id}/templates/{code}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString codePathParam("{");
        codePathParam.append("code").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "code", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"code"+pathSuffix : pathPrefix;
        fullPath.replace(codePathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(code)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::syncGuildTemplateCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::syncGuildTemplateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildTemplateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT syncGuildTemplateSignal(output);
        Q_EMIT syncGuildTemplateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT syncGuildTemplateSignalE(output, error_type, error_str);
        Q_EMIT syncGuildTemplateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT syncGuildTemplateSignalError(output, error_type, error_str);
        Q_EMIT syncGuildTemplateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::threadSearch(const QString &channel_id, const ::dc_rest::OptionalParam<QString> &name, const ::dc_rest::OptionalParam<qint32> &slop, const ::dc_rest::OptionalParam<QString> &min_id, const ::dc_rest::OptionalParam<QString> &max_id, const ::dc_rest::OptionalParam<OAIThread_search_tag_parameter> &tag, const ::dc_rest::OptionalParam<QString> &tag_setting, const ::dc_rest::OptionalParam<bool> &archived, const ::dc_rest::OptionalParam<QString> &sort_by, const ::dc_rest::OptionalParam<QString> &sort_order, const ::dc_rest::OptionalParam<qint32> &limit, const ::dc_rest::OptionalParam<qint32> &offset) {
    QString fullPath = QString(_serverConfigs["threadSearch"][_serverIndices.value("threadSearch")].URL()+"/channels/{channel_id}/threads/search");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (name.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "name", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("name")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(name.stringValue())));
    }
    if (slop.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "slop", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("slop")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(slop.stringValue())));
    }
    if (min_id.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "min_id", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("min_id")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(min_id.stringValue())));
    }
    if (max_id.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "max_id", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("max_id")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(max_id.stringValue())));
    }
    if (tag.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "tag", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");
        QString paramString = (queryStyle == "form" && true) ? "" : (queryStyle == "form" && !(true)) ? "tag"+querySuffix : "";
        QJsonObject parameter = tag.value().asJsonObject();
        qint32 count = 0;
        for(const QString& key : parameter.keys()) {
            if (count > 0) {
                queryDelimiter =  ((queryStyle == "form" || queryStyle == "deepObject") && true) ? "&" : getParamStyleDelimiter(queryStyle, key, true);
                paramString.append(queryDelimiter);
            }
            QString assignOperator;
            if (queryStyle == "form")
                assignOperator = (true) ? "=" : ",";
            else if (queryStyle == "deepObject")
                assignOperator = (true) ? "=" : "none";
            switch(parameter.value(key).type()) {
                case QJsonValue::String:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("tag").append("[").append(key).append("]"))+assignOperator+parameter.value(key).toString());
                    break;
                }
                case QJsonValue::Double:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("tag").append("[").append(key).append("]"))+assignOperator+QString::number(parameter.value(key).toDouble()));
                    break;
                }
                case QJsonValue::Bool:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("tag").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toBool()).toString());
                    break;
                }
                case QJsonValue::Array:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("tag").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toArray()).toString());
                    break;
                }
                case QJsonValue::Object:
                {
                    paramString.append(((queryStyle == "form") ? key : QString("tag").append("[").append(key).append("]"))+assignOperator+QVariant(parameter.value(key).toObject()).toString());
                    break;
                }
                case QJsonValue::Null:
                case QJsonValue::Undefined:
                    break;
            }
            count++;
        }
        fullPath.append(paramString);
            }
    if (tag_setting.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "tag_setting", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("tag_setting")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(tag_setting.stringValue())));
    }
    if (archived.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "archived", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("archived")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(archived.stringValue())));
    }
    if (sort_by.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "sort_by", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("sort_by")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(sort_by.stringValue())));
    }
    if (sort_order.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "sort_order", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("sort_order")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(sort_order.stringValue())));
    }
    if (limit.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "limit", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("limit")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(limit.stringValue())));
    }
    if (offset.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "offset", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("offset")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(offset.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "GET");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::threadSearchCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::threadSearchCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIThreadSearchResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT threadSearchSignal(output);
        Q_EMIT threadSearchSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT threadSearchSignalE(output, error_type, error_str);
        Q_EMIT threadSearchSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT threadSearchSignalError(output, error_type, error_str);
        Q_EMIT threadSearchSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::triggerTypingIndicator(const QString &channel_id) {
    QString fullPath = QString(_serverConfigs["triggerTypingIndicator"][_serverIndices.value("triggerTypingIndicator")].URL()+"/channels/{channel_id}/typing");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::triggerTypingIndicatorCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::triggerTypingIndicatorCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIObject output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT triggerTypingIndicatorSignal(output);
        Q_EMIT triggerTypingIndicatorSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT triggerTypingIndicatorSignalE(output, error_type, error_str);
        Q_EMIT triggerTypingIndicatorSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT triggerTypingIndicatorSignalError(output, error_type, error_str);
        Q_EMIT triggerTypingIndicatorSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::unbanUserFromGuild(const QString &guild_id, const QString &user_id) {
    QString fullPath = QString(_serverConfigs["unbanUserFromGuild"][_serverIndices.value("unbanUserFromGuild")].URL()+"/guilds/{guild_id}/bans/{user_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString user_idPathParam("{");
        user_idPathParam.append("user_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "user_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"user_id"+pathSuffix : pathPrefix;
        fullPath.replace(user_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(user_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "DELETE");


    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::unbanUserFromGuildCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::unbanUserFromGuildCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT unbanUserFromGuildSignal();
        Q_EMIT unbanUserFromGuildSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT unbanUserFromGuildSignalE(error_type, error_str);
        Q_EMIT unbanUserFromGuildSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT unbanUserFromGuildSignalError(error_type, error_str);
        Q_EMIT unbanUserFromGuildSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateApplication(const QString &application_id, const OAIApplicationFormPartial &oai_application_form_partial) {
    QString fullPath = QString(_serverConfigs["updateApplication"][_serverIndices.value("updateApplication")].URL()+"/applications/{application_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_application_form_partial.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateApplicationCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::updateApplicationCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPrivateApplicationResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateApplicationSignal(output);
        Q_EMIT updateApplicationSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateApplicationSignalE(output, error_type, error_str);
        Q_EMIT updateApplicationSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateApplicationSignalError(output, error_type, error_str);
        Q_EMIT updateApplicationSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateApplicationCommand(const QString &application_id, const QString &command_id, const OAIApplicationCommandPatchRequestPartial &oai_application_command_patch_request_partial) {
    QString fullPath = QString(_serverConfigs["updateApplicationCommand"][_serverIndices.value("updateApplicationCommand")].URL()+"/applications/{application_id}/commands/{command_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    
    {
        QString command_idPathParam("{");
        command_idPathParam.append("command_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "command_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"command_id"+pathSuffix : pathPrefix;
        fullPath.replace(command_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(command_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_application_command_patch_request_partial.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("applications.commands.update");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::updateApplicationCommandCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIApplicationCommandResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateApplicationCommandSignal(output);
        Q_EMIT updateApplicationCommandSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.commands.update");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateApplicationCommandSignalE(output, error_type, error_str);
        Q_EMIT updateApplicationCommandSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateApplicationCommandSignalError(output, error_type, error_str);
        Q_EMIT updateApplicationCommandSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateApplicationEmoji(const QString &application_id, const QString &emoji_id, const OAIUpdate_application_emoji_request &oai_update_application_emoji_request) {
    QString fullPath = QString(_serverConfigs["updateApplicationEmoji"][_serverIndices.value("updateApplicationEmoji")].URL()+"/applications/{application_id}/emojis/{emoji_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    
    {
        QString emoji_idPathParam("{");
        emoji_idPathParam.append("emoji_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "emoji_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"emoji_id"+pathSuffix : pathPrefix;
        fullPath.replace(emoji_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(emoji_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_update_application_emoji_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateApplicationEmojiCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::updateApplicationEmojiCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIEmojiResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateApplicationEmojiSignal(output);
        Q_EMIT updateApplicationEmojiSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateApplicationEmojiSignalE(output, error_type, error_str);
        Q_EMIT updateApplicationEmojiSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateApplicationEmojiSignalError(output, error_type, error_str);
        Q_EMIT updateApplicationEmojiSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateApplicationRoleConnectionsMetadata(const QString &application_id, const QList<OAIApplicationRoleConnectionsMetadataItemRequest> &oai_application_role_connections_metadata_item_request) {
    QString fullPath = QString(_serverConfigs["updateApplicationRoleConnectionsMetadata"][_serverIndices.value("updateApplicationRoleConnectionsMetadata")].URL()+"/applications/{application_id}/role-connections/metadata");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {
        QJsonDocument doc(::dc_rest::toJsonValue(oai_application_role_connections_metadata_item_request).toArray());
        QByteArray bytes = doc.toJson();
        input.request_body.append(bytes);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateApplicationRoleConnectionsMetadataCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::updateApplicationRoleConnectionsMetadataCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    QList<OAIApplicationRoleConnectionsMetadataItemResponse> output;
    QString json(worker->response);
    QByteArray array(json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonArray jsonArray = doc.array();
    for (QJsonValue obj : jsonArray) {
        OAIApplicationRoleConnectionsMetadataItemResponse val;
        ::dc_rest::fromJsonValue(val, obj);
        output.append(val);
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateApplicationRoleConnectionsMetadataSignal(output);
        Q_EMIT updateApplicationRoleConnectionsMetadataSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateApplicationRoleConnectionsMetadataSignalE(output, error_type, error_str);
        Q_EMIT updateApplicationRoleConnectionsMetadataSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateApplicationRoleConnectionsMetadataSignalError(output, error_type, error_str);
        Q_EMIT updateApplicationRoleConnectionsMetadataSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateApplicationUserRoleConnection(const QString &application_id, const OAIUpdateApplicationUserRoleConnectionRequest &oai_update_application_user_role_connection_request) {
    QString fullPath = QString(_serverConfigs["updateApplicationUserRoleConnection"][_serverIndices.value("updateApplicationUserRoleConnection")].URL()+"/users/@me/applications/{application_id}/role-connection");
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PUT");

    {

        
        QByteArray output = oai_update_application_user_role_connection_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateApplicationUserRoleConnectionCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateApplicationUserRoleConnectionCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateApplicationUserRoleConnectionCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("role_connections.write");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateApplicationUserRoleConnectionCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::updateApplicationUserRoleConnectionCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIApplicationUserRoleConnectionResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateApplicationUserRoleConnectionSignal(output);
        Q_EMIT updateApplicationUserRoleConnectionSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("role_connections.write");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateApplicationUserRoleConnectionSignalE(output, error_type, error_str);
        Q_EMIT updateApplicationUserRoleConnectionSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateApplicationUserRoleConnectionSignalError(output, error_type, error_str);
        Q_EMIT updateApplicationUserRoleConnectionSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateAutoModerationRule(const QString &guild_id, const QString &rule_id, const OAIUpdate_auto_moderation_rule_request &oai_update_auto_moderation_rule_request) {
    QString fullPath = QString(_serverConfigs["updateAutoModerationRule"][_serverIndices.value("updateAutoModerationRule")].URL()+"/guilds/{guild_id}/auto-moderation/rules/{rule_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString rule_idPathParam("{");
        rule_idPathParam.append("rule_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "rule_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"rule_id"+pathSuffix : pathPrefix;
        fullPath.replace(rule_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(rule_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_update_auto_moderation_rule_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateAutoModerationRuleCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::updateAutoModerationRuleCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAICreate_auto_moderation_rule_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateAutoModerationRuleSignal(output);
        Q_EMIT updateAutoModerationRuleSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateAutoModerationRuleSignalE(output, error_type, error_str);
        Q_EMIT updateAutoModerationRuleSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateAutoModerationRuleSignalError(output, error_type, error_str);
        Q_EMIT updateAutoModerationRuleSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateChannel(const QString &channel_id, const OAIUpdate_channel_request &oai_update_channel_request) {
    QString fullPath = QString(_serverConfigs["updateChannel"][_serverIndices.value("updateChannel")].URL()+"/channels/{channel_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_update_channel_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateChannelCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::updateChannelCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGet_channel_200_response output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateChannelSignal(output);
        Q_EMIT updateChannelSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateChannelSignalE(output, error_type, error_str);
        Q_EMIT updateChannelSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateChannelSignalError(output, error_type, error_str);
        Q_EMIT updateChannelSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateGuild(const QString &guild_id, const OAIGuildPatchRequestPartial &oai_guild_patch_request_partial) {
    QString fullPath = QString(_serverConfigs["updateGuild"][_serverIndices.value("updateGuild")].URL()+"/guilds/{guild_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_guild_patch_request_partial.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateGuildCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::updateGuildCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateGuildSignal(output);
        Q_EMIT updateGuildSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateGuildSignalE(output, error_type, error_str);
        Q_EMIT updateGuildSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateGuildSignalError(output, error_type, error_str);
        Q_EMIT updateGuildSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateGuildApplicationCommand(const QString &application_id, const QString &guild_id, const QString &command_id, const OAIApplicationCommandPatchRequestPartial &oai_application_command_patch_request_partial) {
    QString fullPath = QString(_serverConfigs["updateGuildApplicationCommand"][_serverIndices.value("updateGuildApplicationCommand")].URL()+"/applications/{application_id}/guilds/{guild_id}/commands/{command_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString command_idPathParam("{");
        command_idPathParam.append("command_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "command_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"command_id"+pathSuffix : pathPrefix;
        fullPath.replace(command_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(command_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_application_command_patch_request_partial.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateGuildApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateGuildApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("applications.commands.update");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateGuildApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateGuildApplicationCommandCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::updateGuildApplicationCommandCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIApplicationCommandResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateGuildApplicationCommandSignal(output);
        Q_EMIT updateGuildApplicationCommandSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("applications.commands.update");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateGuildApplicationCommandSignalE(output, error_type, error_str);
        Q_EMIT updateGuildApplicationCommandSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateGuildApplicationCommandSignalError(output, error_type, error_str);
        Q_EMIT updateGuildApplicationCommandSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateGuildEmoji(const QString &guild_id, const QString &emoji_id, const OAIUpdate_guild_emoji_request &oai_update_guild_emoji_request) {
    QString fullPath = QString(_serverConfigs["updateGuildEmoji"][_serverIndices.value("updateGuildEmoji")].URL()+"/guilds/{guild_id}/emojis/{emoji_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString emoji_idPathParam("{");
        emoji_idPathParam.append("emoji_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "emoji_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"emoji_id"+pathSuffix : pathPrefix;
        fullPath.replace(emoji_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(emoji_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_update_guild_emoji_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateGuildEmojiCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::updateGuildEmojiCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIEmojiResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateGuildEmojiSignal(output);
        Q_EMIT updateGuildEmojiSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateGuildEmojiSignalE(output, error_type, error_str);
        Q_EMIT updateGuildEmojiSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateGuildEmojiSignalError(output, error_type, error_str);
        Q_EMIT updateGuildEmojiSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateGuildMember(const QString &guild_id, const QString &user_id, const OAIUpdate_guild_member_request &oai_update_guild_member_request) {
    QString fullPath = QString(_serverConfigs["updateGuildMember"][_serverIndices.value("updateGuildMember")].URL()+"/guilds/{guild_id}/members/{user_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString user_idPathParam("{");
        user_idPathParam.append("user_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "user_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"user_id"+pathSuffix : pathPrefix;
        fullPath.replace(user_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(user_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_update_guild_member_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateGuildMemberCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::updateGuildMemberCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildMemberResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateGuildMemberSignal(output);
        Q_EMIT updateGuildMemberSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateGuildMemberSignalE(output, error_type, error_str);
        Q_EMIT updateGuildMemberSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateGuildMemberSignalError(output, error_type, error_str);
        Q_EMIT updateGuildMemberSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateGuildRole(const QString &guild_id, const QString &role_id, const OAICreate_guild_role_request &oai_create_guild_role_request) {
    QString fullPath = QString(_serverConfigs["updateGuildRole"][_serverIndices.value("updateGuildRole")].URL()+"/guilds/{guild_id}/roles/{role_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString role_idPathParam("{");
        role_idPathParam.append("role_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "role_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"role_id"+pathSuffix : pathPrefix;
        fullPath.replace(role_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(role_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_create_guild_role_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateGuildRoleCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::updateGuildRoleCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildRoleResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateGuildRoleSignal(output);
        Q_EMIT updateGuildRoleSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateGuildRoleSignalE(output, error_type, error_str);
        Q_EMIT updateGuildRoleSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateGuildRoleSignalError(output, error_type, error_str);
        Q_EMIT updateGuildRoleSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateGuildScheduledEvent(const QString &guild_id, const QString &guild_scheduled_event_id, const OAIUpdate_guild_scheduled_event_request &oai_update_guild_scheduled_event_request) {
    QString fullPath = QString(_serverConfigs["updateGuildScheduledEvent"][_serverIndices.value("updateGuildScheduledEvent")].URL()+"/guilds/{guild_id}/scheduled-events/{guild_scheduled_event_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString guild_scheduled_event_idPathParam("{");
        guild_scheduled_event_idPathParam.append("guild_scheduled_event_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_scheduled_event_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_scheduled_event_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_scheduled_event_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_scheduled_event_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_update_guild_scheduled_event_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateGuildScheduledEventCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::updateGuildScheduledEventCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIList_guild_scheduled_events_200_response_inner output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateGuildScheduledEventSignal(output);
        Q_EMIT updateGuildScheduledEventSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateGuildScheduledEventSignalE(output, error_type, error_str);
        Q_EMIT updateGuildScheduledEventSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateGuildScheduledEventSignalError(output, error_type, error_str);
        Q_EMIT updateGuildScheduledEventSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateGuildSoundboardSound(const QString &guild_id, const QString &sound_id, const OAISoundboardPatchRequestPartial &oai_soundboard_patch_request_partial) {
    QString fullPath = QString(_serverConfigs["updateGuildSoundboardSound"][_serverIndices.value("updateGuildSoundboardSound")].URL()+"/guilds/{guild_id}/soundboard-sounds/{sound_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString sound_idPathParam("{");
        sound_idPathParam.append("sound_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "sound_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"sound_id"+pathSuffix : pathPrefix;
        fullPath.replace(sound_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(sound_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_soundboard_patch_request_partial.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateGuildSoundboardSoundCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::updateGuildSoundboardSoundCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAISoundboardSoundResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateGuildSoundboardSoundSignal(output);
        Q_EMIT updateGuildSoundboardSoundSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateGuildSoundboardSoundSignalE(output, error_type, error_str);
        Q_EMIT updateGuildSoundboardSoundSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateGuildSoundboardSoundSignalError(output, error_type, error_str);
        Q_EMIT updateGuildSoundboardSoundSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateGuildSticker(const QString &guild_id, const QString &sticker_id, const OAIUpdate_guild_sticker_request &oai_update_guild_sticker_request) {
    QString fullPath = QString(_serverConfigs["updateGuildSticker"][_serverIndices.value("updateGuildSticker")].URL()+"/guilds/{guild_id}/stickers/{sticker_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString sticker_idPathParam("{");
        sticker_idPathParam.append("sticker_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "sticker_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"sticker_id"+pathSuffix : pathPrefix;
        fullPath.replace(sticker_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(sticker_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_update_guild_sticker_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateGuildStickerCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::updateGuildStickerCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildStickerResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateGuildStickerSignal(output);
        Q_EMIT updateGuildStickerSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateGuildStickerSignalE(output, error_type, error_str);
        Q_EMIT updateGuildStickerSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateGuildStickerSignalError(output, error_type, error_str);
        Q_EMIT updateGuildStickerSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateGuildTemplate(const QString &guild_id, const QString &code, const OAIUpdate_guild_template_request &oai_update_guild_template_request) {
    QString fullPath = QString(_serverConfigs["updateGuildTemplate"][_serverIndices.value("updateGuildTemplate")].URL()+"/guilds/{guild_id}/templates/{code}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString codePathParam("{");
        codePathParam.append("code").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "code", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"code"+pathSuffix : pathPrefix;
        fullPath.replace(codePathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(code)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_update_guild_template_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateGuildTemplateCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::updateGuildTemplateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildTemplateResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateGuildTemplateSignal(output);
        Q_EMIT updateGuildTemplateSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateGuildTemplateSignalE(output, error_type, error_str);
        Q_EMIT updateGuildTemplateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateGuildTemplateSignalError(output, error_type, error_str);
        Q_EMIT updateGuildTemplateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateGuildWelcomeScreen(const QString &guild_id, const OAIWelcomeScreenPatchRequestPartial &oai_welcome_screen_patch_request_partial) {
    QString fullPath = QString(_serverConfigs["updateGuildWelcomeScreen"][_serverIndices.value("updateGuildWelcomeScreen")].URL()+"/guilds/{guild_id}/welcome-screen");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_welcome_screen_patch_request_partial.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateGuildWelcomeScreenCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::updateGuildWelcomeScreenCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIGuildWelcomeScreenResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateGuildWelcomeScreenSignal(output);
        Q_EMIT updateGuildWelcomeScreenSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateGuildWelcomeScreenSignalE(output, error_type, error_str);
        Q_EMIT updateGuildWelcomeScreenSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateGuildWelcomeScreenSignalError(output, error_type, error_str);
        Q_EMIT updateGuildWelcomeScreenSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateGuildWidgetSettings(const QString &guild_id, const OAIUpdate_guild_widget_settings_request &oai_update_guild_widget_settings_request) {
    QString fullPath = QString(_serverConfigs["updateGuildWidgetSettings"][_serverIndices.value("updateGuildWidgetSettings")].URL()+"/guilds/{guild_id}/widget");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_update_guild_widget_settings_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateGuildWidgetSettingsCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::updateGuildWidgetSettingsCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIWidgetSettingsResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateGuildWidgetSettingsSignal(output);
        Q_EMIT updateGuildWidgetSettingsSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateGuildWidgetSettingsSignalE(output, error_type, error_str);
        Q_EMIT updateGuildWidgetSettingsSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateGuildWidgetSettingsSignalError(output, error_type, error_str);
        Q_EMIT updateGuildWidgetSettingsSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateMessage(const QString &channel_id, const QString &message_id, const OAIMessageEditRequestPartial &oai_message_edit_request_partial) {
    QString fullPath = QString(_serverConfigs["updateMessage"][_serverIndices.value("updateMessage")].URL()+"/channels/{channel_id}/messages/{message_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    
    {
        QString message_idPathParam("{");
        message_idPathParam.append("message_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "message_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"message_id"+pathSuffix : pathPrefix;
        fullPath.replace(message_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(message_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_message_edit_request_partial.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateMessageCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::updateMessageCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessageResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateMessageSignal(output);
        Q_EMIT updateMessageSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateMessageSignalE(output, error_type, error_str);
        Q_EMIT updateMessageSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateMessageSignalError(output, error_type, error_str);
        Q_EMIT updateMessageSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateMyApplication(const OAIApplicationFormPartial &oai_application_form_partial) {
    QString fullPath = QString(_serverConfigs["updateMyApplication"][_serverIndices.value("updateMyApplication")].URL()+"/applications/@me");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_application_form_partial.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateMyApplicationCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::updateMyApplicationCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPrivateApplicationResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateMyApplicationSignal(output);
        Q_EMIT updateMyApplicationSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateMyApplicationSignalE(output, error_type, error_str);
        Q_EMIT updateMyApplicationSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateMyApplicationSignalError(output, error_type, error_str);
        Q_EMIT updateMyApplicationSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateMyGuildMember(const QString &guild_id, const OAIUpdate_my_guild_member_request &oai_update_my_guild_member_request) {
    QString fullPath = QString(_serverConfigs["updateMyGuildMember"][_serverIndices.value("updateMyGuildMember")].URL()+"/guilds/{guild_id}/members/@me");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_update_my_guild_member_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateMyGuildMemberCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::updateMyGuildMemberCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIPrivateGuildMemberResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateMyGuildMemberSignal(output);
        Q_EMIT updateMyGuildMemberSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateMyGuildMemberSignalE(output, error_type, error_str);
        Q_EMIT updateMyGuildMemberSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateMyGuildMemberSignalError(output, error_type, error_str);
        Q_EMIT updateMyGuildMemberSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateMyUser(const OAIBotAccountPatchRequest &oai_bot_account_patch_request) {
    QString fullPath = QString(_serverConfigs["updateMyUser"][_serverIndices.value("updateMyUser")].URL()+"/users/@me");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_bot_account_patch_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateMyUserCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::updateMyUserCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIUserPIIResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateMyUserSignal(output);
        Q_EMIT updateMyUserSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateMyUserSignalE(output, error_type, error_str);
        Q_EMIT updateMyUserSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateMyUserSignalError(output, error_type, error_str);
        Q_EMIT updateMyUserSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateOriginalWebhookMessage(const QString &webhook_id, const QString &webhook_token, const OAIIncomingWebhookUpdateRequestPartial &oai_incoming_webhook_update_request_partial, const ::dc_rest::OptionalParam<QString> &thread_id, const ::dc_rest::OptionalParam<bool> &with_components) {
    QString fullPath = QString(_serverConfigs["updateOriginalWebhookMessage"][_serverIndices.value("updateOriginalWebhookMessage")].URL()+"/webhooks/{webhook_id}/{webhook_token}/messages/@original");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString webhook_idPathParam("{");
        webhook_idPathParam.append("webhook_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_id"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_id)));
    }
    
    {
        QString webhook_tokenPathParam("{");
        webhook_tokenPathParam.append("webhook_token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_token"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_tokenPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_token)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (thread_id.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "thread_id", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("thread_id")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(thread_id.stringValue())));
    }
    if (with_components.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "with_components", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("with_components")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(with_components.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_incoming_webhook_update_request_partial.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateOriginalWebhookMessageCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::updateOriginalWebhookMessageCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessageResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateOriginalWebhookMessageSignal(output);
        Q_EMIT updateOriginalWebhookMessageSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateOriginalWebhookMessageSignalE(output, error_type, error_str);
        Q_EMIT updateOriginalWebhookMessageSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateOriginalWebhookMessageSignalError(output, error_type, error_str);
        Q_EMIT updateOriginalWebhookMessageSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateSelfVoiceState(const QString &guild_id, const OAIUpdate_self_voice_state_request &oai_update_self_voice_state_request) {
    QString fullPath = QString(_serverConfigs["updateSelfVoiceState"][_serverIndices.value("updateSelfVoiceState")].URL()+"/guilds/{guild_id}/voice-states/@me");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_update_self_voice_state_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateSelfVoiceStateCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::updateSelfVoiceStateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateSelfVoiceStateSignal();
        Q_EMIT updateSelfVoiceStateSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateSelfVoiceStateSignalE(error_type, error_str);
        Q_EMIT updateSelfVoiceStateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateSelfVoiceStateSignalError(error_type, error_str);
        Q_EMIT updateSelfVoiceStateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateStageInstance(const QString &channel_id, const OAIUpdate_stage_instance_request &oai_update_stage_instance_request) {
    QString fullPath = QString(_serverConfigs["updateStageInstance"][_serverIndices.value("updateStageInstance")].URL()+"/stage-instances/{channel_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString channel_idPathParam("{");
        channel_idPathParam.append("channel_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "channel_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"channel_id"+pathSuffix : pathPrefix;
        fullPath.replace(channel_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(channel_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_update_stage_instance_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateStageInstanceCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::updateStageInstanceCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIStageInstanceResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateStageInstanceSignal(output);
        Q_EMIT updateStageInstanceSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateStageInstanceSignalE(output, error_type, error_str);
        Q_EMIT updateStageInstanceSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateStageInstanceSignalError(output, error_type, error_str);
        Q_EMIT updateStageInstanceSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateVoiceState(const QString &guild_id, const QString &user_id, const OAIUpdate_voice_state_request &oai_update_voice_state_request) {
    QString fullPath = QString(_serverConfigs["updateVoiceState"][_serverIndices.value("updateVoiceState")].URL()+"/guilds/{guild_id}/voice-states/{user_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString guild_idPathParam("{");
        guild_idPathParam.append("guild_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "guild_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"guild_id"+pathSuffix : pathPrefix;
        fullPath.replace(guild_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(guild_id)));
    }
    
    {
        QString user_idPathParam("{");
        user_idPathParam.append("user_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "user_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"user_id"+pathSuffix : pathPrefix;
        fullPath.replace(user_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(user_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_update_voice_state_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateVoiceStateCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::updateVoiceStateCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateVoiceStateSignal();
        Q_EMIT updateVoiceStateSignalFull(worker);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateVoiceStateSignalE(error_type, error_str);
        Q_EMIT updateVoiceStateSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateVoiceStateSignalError(error_type, error_str);
        Q_EMIT updateVoiceStateSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateWebhook(const QString &webhook_id, const OAIUpdate_webhook_request &oai_update_webhook_request) {
    QString fullPath = QString(_serverConfigs["updateWebhook"][_serverIndices.value("updateWebhook")].URL()+"/webhooks/{webhook_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString webhook_idPathParam("{");
        webhook_idPathParam.append("webhook_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_id"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_update_webhook_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateWebhookCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::updateWebhookCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIList_channel_webhooks_200_response_inner output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateWebhookSignal(output);
        Q_EMIT updateWebhookSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateWebhookSignalE(output, error_type, error_str);
        Q_EMIT updateWebhookSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateWebhookSignalError(output, error_type, error_str);
        Q_EMIT updateWebhookSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateWebhookByToken(const QString &webhook_id, const QString &webhook_token, const OAIUpdate_webhook_by_token_request &oai_update_webhook_by_token_request) {
    QString fullPath = QString(_serverConfigs["updateWebhookByToken"][_serverIndices.value("updateWebhookByToken")].URL()+"/webhooks/{webhook_id}/{webhook_token}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString webhook_idPathParam("{");
        webhook_idPathParam.append("webhook_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_id"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_id)));
    }
    
    {
        QString webhook_tokenPathParam("{");
        webhook_tokenPathParam.append("webhook_token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_token"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_tokenPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_token)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_update_webhook_by_token_request.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateWebhookByTokenCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::updateWebhookByTokenCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIList_channel_webhooks_200_response_inner output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateWebhookByTokenSignal(output);
        Q_EMIT updateWebhookByTokenSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateWebhookByTokenSignalE(output, error_type, error_str);
        Q_EMIT updateWebhookByTokenSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateWebhookByTokenSignalError(output, error_type, error_str);
        Q_EMIT updateWebhookByTokenSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::updateWebhookMessage(const QString &webhook_id, const QString &webhook_token, const QString &message_id, const OAIIncomingWebhookUpdateRequestPartial &oai_incoming_webhook_update_request_partial, const ::dc_rest::OptionalParam<QString> &thread_id, const ::dc_rest::OptionalParam<bool> &with_components) {
    QString fullPath = QString(_serverConfigs["updateWebhookMessage"][_serverIndices.value("updateWebhookMessage")].URL()+"/webhooks/{webhook_id}/{webhook_token}/messages/{message_id}");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString webhook_idPathParam("{");
        webhook_idPathParam.append("webhook_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_id"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_id)));
    }
    
    {
        QString webhook_tokenPathParam("{");
        webhook_tokenPathParam.append("webhook_token").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "webhook_token", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"webhook_token"+pathSuffix : pathPrefix;
        fullPath.replace(webhook_tokenPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(webhook_token)));
    }
    
    {
        QString message_idPathParam("{");
        message_idPathParam.append("message_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "message_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"message_id"+pathSuffix : pathPrefix;
        fullPath.replace(message_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(message_id)));
    }
    QString queryPrefix, querySuffix, queryDelimiter, queryStyle;
    if (thread_id.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "thread_id", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("thread_id")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(thread_id.stringValue())));
    }
    if (with_components.hasValue())
    {
        queryStyle = "form";
        if (queryStyle == "")
            queryStyle = "form";
        queryPrefix = getParamStylePrefix(queryStyle);
        querySuffix = getParamStyleSuffix(queryStyle);
        queryDelimiter = getParamStyleDelimiter(queryStyle, "with_components", true);
        if (fullPath.indexOf("?") > 0)
            fullPath.append(queryPrefix);
        else
            fullPath.append("?");

        fullPath.append(QUrl::toPercentEncoding("with_components")).append(querySuffix).append(QUrl::toPercentEncoding(::dc_rest::toStringValue(with_components.stringValue())));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "PATCH");

    {

        
        QByteArray output = oai_incoming_webhook_update_request_partial.asJson().toUtf8();
        input.request_body.append(output);
    }
    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::updateWebhookMessageCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    worker->execute(&input);
}

void OAIDefaultApi::updateWebhookMessageCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIMessageResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT updateWebhookMessageSignal(output);
        Q_EMIT updateWebhookMessageSignalFull(worker, output);
    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT updateWebhookMessageSignalE(output, error_type, error_str);
        Q_EMIT updateWebhookMessageSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT updateWebhookMessageSignalError(output, error_type, error_str);
        Q_EMIT updateWebhookMessageSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::uploadApplicationAttachment(const QString &application_id, const QString &file) {
    QString fullPath = QString(_serverConfigs["uploadApplicationAttachment"][_serverIndices.value("uploadApplicationAttachment")].URL()+"/applications/{application_id}/attachment");
    
    if (_apiKeys.contains("BotToken")) {
        addHeaders("BotToken",_apiKeys.find("BotToken").value());
    }
    
    
    {
        QString application_idPathParam("{");
        application_idPathParam.append("application_id").append("}");
        QString pathPrefix, pathSuffix, pathDelimiter;
        QString pathStyle = "simple";
        if (pathStyle == "")
            pathStyle = "simple";
        pathPrefix = getParamStylePrefix(pathStyle);
        pathSuffix = getParamStyleSuffix(pathStyle);
        pathDelimiter = getParamStyleDelimiter(pathStyle, "application_id", false);
        QString paramString = (pathStyle == "matrix") ? pathPrefix+"application_id"+pathSuffix : pathPrefix;
        fullPath.replace(application_idPathParam, paramString+QUrl::toPercentEncoding(::dc_rest::toStringValue(application_id)));
    }
    OAIHttpRequestWorker *worker = new OAIHttpRequestWorker(this, _manager);
    worker->setTimeOut(_timeOut);
    worker->setWorkingDirectory(_workingDirectory);
    OAIHttpRequestInput input(fullPath, "POST");

    
    {
        input.add_var("file", ::dc_rest::toStringValue(file));
    }

    for (auto keyValueIt = _defaultHeaders.keyValueBegin(); keyValueIt != _defaultHeaders.keyValueEnd(); keyValueIt++) {
        input.headers.insert(keyValueIt->first, keyValueIt->second);
    }


    connect(worker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::uploadApplicationAttachmentCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, worker, &QObject::deleteLater);
    connect(worker, &QObject::destroyed, this, [this] {
        if (findChildren<OAIHttpRequestWorker*>().count() == 0) {
            Q_EMIT allPendingRequestsCompleted();
        }
    });
    _OauthMethod = 1;
    _implicitFlow.link();
    _passwordFlow.unlink();
    _authFlow.unlink();
    _credentialFlow.unlink();
    QStringList scope;
    scope.append("activities.invites.write");
    scope.append("activities.read");
    scope.append("activities.write");
    scope.append("applications.builds.read");
    scope.append("applications.builds.upload");
    scope.append("applications.commands");
    scope.append("applications.commands.permissions.update");
    scope.append("applications.entitlements");
    scope.append("applications.store.update");
    scope.append("bot");
    scope.append("connections");
    scope.append("dm_channels.read");
    scope.append("email");
    scope.append("gdm.join");
    scope.append("guilds");
    scope.append("guilds.join");
    scope.append("guilds.members.read");
    scope.append("identify");
    scope.append("messages.read");
    scope.append("openid");
    scope.append("relationships.read");
    scope.append("rpc");
    scope.append("rpc.activities.write");
    scope.append("rpc.notifications.read");
    scope.append("rpc.screenshare.read");
    scope.append("rpc.screenshare.write");
    scope.append("rpc.video.read");
    scope.append("rpc.video.write");
    scope.append("rpc.voice.read");
    scope.append("rpc.voice.write");
    scope.append("voice");
    scope.append("webhook.incoming");
    auto token = _implicitFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::uploadApplicationAttachmentCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;



    _OauthMethod = 3;
    _authFlow.unlink();
    _implicitFlow.unlink();
    _passwordFlow.unlink();
    _credentialFlow.link();
    QStringList scope;
    scope.append("activities.invites.write");
    scope.append("activities.read");
    scope.append("activities.write");
    scope.append("applications.builds.read");
    scope.append("applications.builds.upload");
    scope.append("applications.commands");
    scope.append("applications.commands.permissions.update");
    scope.append("applications.commands.update");
    scope.append("applications.entitlements");
    scope.append("applications.store.update");
    scope.append("bot");
    scope.append("connections");
    scope.append("dm_channels.read");
    scope.append("email");
    scope.append("gdm.join");
    scope.append("guilds");
    scope.append("guilds.join");
    scope.append("guilds.members.read");
    scope.append("identify");
    scope.append("messages.read");
    scope.append("openid");
    scope.append("relationships.read");
    scope.append("rpc");
    scope.append("rpc.activities.write");
    scope.append("rpc.notifications.read");
    scope.append("rpc.screenshare.read");
    scope.append("rpc.screenshare.write");
    scope.append("rpc.video.read");
    scope.append("rpc.video.write");
    scope.append("rpc.voice.read");
    scope.append("rpc.voice.write");
    scope.append("voice");
    scope.append("webhook.incoming");
    auto token = _credentialFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::uploadApplicationAttachmentCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;

    _OauthMethod = 2;
    _implicitFlow.unlink();
    _credentialFlow.unlink();
    _passwordFlow.unlink();
    _authFlow.link();
    QStringList scope;
    scope.append("activities.invites.write");
    scope.append("activities.read");
    scope.append("activities.write");
    scope.append("applications.builds.read");
    scope.append("applications.builds.upload");
    scope.append("applications.commands");
    scope.append("applications.commands.permissions.update");
    scope.append("applications.entitlements");
    scope.append("applications.store.update");
    scope.append("bot");
    scope.append("connections");
    scope.append("dm_channels.read");
    scope.append("email");
    scope.append("gdm.join");
    scope.append("guilds");
    scope.append("guilds.join");
    scope.append("guilds.members.read");
    scope.append("identify");
    scope.append("messages.read");
    scope.append("openid");
    scope.append("relationships.read");
    scope.append("role_connections.write");
    scope.append("rpc");
    scope.append("rpc.activities.write");
    scope.append("rpc.notifications.read");
    scope.append("rpc.screenshare.read");
    scope.append("rpc.screenshare.write");
    scope.append("rpc.video.read");
    scope.append("rpc.video.write");
    scope.append("rpc.voice.read");
    scope.append("rpc.voice.write");
    scope.append("voice");
    scope.append("webhook.incoming");
    auto token = _authFlow.getToken(scope.join(" "));
    if(token.isValid())
        input.headers.insert("Authorization", "Bearer " + token.getToken());

    _latestWorker = new OAIHttpRequestWorker(this, _manager);
    _latestWorker->setTimeOut(_timeOut);
    _latestWorker->setWorkingDirectory(_workingDirectory);

    connect(_latestWorker, &OAIHttpRequestWorker::on_execution_finished, this, &OAIDefaultApi::uploadApplicationAttachmentCallback);
    connect(this, &OAIDefaultApi::abortRequestsSignal, _latestWorker, &QObject::deleteLater);
    connect(_latestWorker, &QObject::destroyed, this, [this] {
        if(findChildren<OAIHttpRequestWorker*>().count() == 0){
            Q_EMIT allPendingRequestsCompleted();
        }
    });

    _latestInput = input;
    _latestScope = scope;




    worker->execute(&input);
}

void OAIDefaultApi::uploadApplicationAttachmentCallback(OAIHttpRequestWorker *worker) {
    QString error_str = worker->error_str;
    QNetworkReply::NetworkError error_type = worker->error_type;

    if (worker->error_type != QNetworkReply::NoError) {
        error_str = QString("%1, %2").arg(worker->error_str, QString(worker->response));
    }
    OAIActivitiesAttachmentResponse output(QString(worker->response));
    worker->deleteLater();

    if (worker->error_type == QNetworkReply::NoError) {
        Q_EMIT uploadApplicationAttachmentSignal(output);
        Q_EMIT uploadApplicationAttachmentSignalFull(worker, output);
    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_implicitFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("activities.invites.write");
        scope.append("activities.read");
        scope.append("activities.write");
        scope.append("applications.builds.read");
        scope.append("applications.builds.upload");
        scope.append("applications.commands");
        scope.append("applications.commands.permissions.update");
        scope.append("applications.entitlements");
        scope.append("applications.store.update");
        scope.append("bot");
        scope.append("connections");
        scope.append("dm_channels.read");
        scope.append("email");
        scope.append("gdm.join");
        scope.append("guilds");
        scope.append("guilds.join");
        scope.append("guilds.members.read");
        scope.append("identify");
        scope.append("messages.read");
        scope.append("openid");
        scope.append("relationships.read");
        scope.append("rpc");
        scope.append("rpc.activities.write");
        scope.append("rpc.notifications.read");
        scope.append("rpc.screenshare.read");
        scope.append("rpc.screenshare.write");
        scope.append("rpc.video.read");
        scope.append("rpc.video.write");
        scope.append("rpc.voice.read");
        scope.append("rpc.voice.write");
        scope.append("voice");
        scope.append("webhook.incoming");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _implicitFlow.setVariables(authorizationUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId");
        Q_EMIT _implicitFlow.authenticationNeeded();



    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_credentialFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("activities.invites.write");
        scope.append("activities.read");
        scope.append("activities.write");
        scope.append("applications.builds.read");
        scope.append("applications.builds.upload");
        scope.append("applications.commands");
        scope.append("applications.commands.permissions.update");
        scope.append("applications.commands.update");
        scope.append("applications.entitlements");
        scope.append("applications.store.update");
        scope.append("bot");
        scope.append("connections");
        scope.append("dm_channels.read");
        scope.append("email");
        scope.append("gdm.join");
        scope.append("guilds");
        scope.append("guilds.join");
        scope.append("guilds.members.read");
        scope.append("identify");
        scope.append("messages.read");
        scope.append("openid");
        scope.append("relationships.read");
        scope.append("rpc");
        scope.append("rpc.activities.write");
        scope.append("rpc.notifications.read");
        scope.append("rpc.screenshare.read");
        scope.append("rpc.screenshare.write");
        scope.append("rpc.video.read");
        scope.append("rpc.video.write");
        scope.append("rpc.voice.read");
        scope.append("rpc.voice.write");
        scope.append("voice");
        scope.append("webhook.incoming");
        QString scopeStr = scope.join(" ");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _credentialFlow.setVariables(tokenUrl , scopeStr, "clientId", "clientSecret");
        Q_EMIT _credentialFlow.authenticationNeeded();

    } else if(worker->error_type == QNetworkReply::AuthenticationRequiredError){
        connect(&_authFlow, SIGNAL(tokenReceived()), this, SLOT(tokenAvailable()));
        QStringList scope;
        scope.append("activities.invites.write");
        scope.append("activities.read");
        scope.append("activities.write");
        scope.append("applications.builds.read");
        scope.append("applications.builds.upload");
        scope.append("applications.commands");
        scope.append("applications.commands.permissions.update");
        scope.append("applications.entitlements");
        scope.append("applications.store.update");
        scope.append("bot");
        scope.append("connections");
        scope.append("dm_channels.read");
        scope.append("email");
        scope.append("gdm.join");
        scope.append("guilds");
        scope.append("guilds.join");
        scope.append("guilds.members.read");
        scope.append("identify");
        scope.append("messages.read");
        scope.append("openid");
        scope.append("relationships.read");
        scope.append("role_connections.write");
        scope.append("rpc");
        scope.append("rpc.activities.write");
        scope.append("rpc.notifications.read");
        scope.append("rpc.screenshare.read");
        scope.append("rpc.screenshare.write");
        scope.append("rpc.video.read");
        scope.append("rpc.video.write");
        scope.append("rpc.voice.read");
        scope.append("rpc.voice.write");
        scope.append("voice");
        scope.append("webhook.incoming");
        QString scopeStr = scope.join(" ");
        QString authorizationUrl("https://discord.com/api/oauth2/authorize");
        QString tokenUrl("https://discord.com/api/oauth2/token");
        //TODO get clientID and Secret and state in the config? https://swagger.io/docs/specification/authentication/oauth2/ states that you should do as you like
        _authFlow.setVariables(authorizationUrl, tokenUrl, scopeStr, "state" , "http://127.0.0.1:9999", "clientId", "clientSecret");
        Q_EMIT _authFlow.authenticationNeeded();



    } else {

#if defined(_MSC_VER)
// For MSVC
#pragma warning(push)
#pragma warning(disable : 4996)
#elif defined(__clang__)
// For Clang
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#elif defined(__GNUC__)
// For GCC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#endif

        Q_EMIT uploadApplicationAttachmentSignalE(output, error_type, error_str);
        Q_EMIT uploadApplicationAttachmentSignalEFull(worker, error_type, error_str);

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

        Q_EMIT uploadApplicationAttachmentSignalError(output, error_type, error_str);
        Q_EMIT uploadApplicationAttachmentSignalErrorFull(worker, error_type, error_str);
    }
}

void OAIDefaultApi::tokenAvailable(){

    oauthToken token;
    switch (_OauthMethod) {
    case 1: //implicit flow
        token = _implicitFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _implicitFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 2: //authorization flow
        token = _authFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _authFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 3: //client credentials flow
        token = _credentialFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    case 4: //resource owner password flow
        token = _passwordFlow.getToken(_latestScope.join(" "));
        if(token.isValid()){
            _latestInput.headers.insert("Authorization", "Bearer " + token.getToken());
            _latestWorker->execute(&_latestInput);
        }else{
            _credentialFlow.removeToken(_latestScope.join(" "));
            qDebug() << "Could not retrieve a valid token";
        }
        break;
    default:
        qDebug() << "No Oauth method set!";
        break;
    }
}
} // namespace dc_rest
